{"meta":{"title":"Blackgan","subtitle":null,"description":"只要这一秒不失望,下一秒就还有希望","author":"Blackgan","url":"http://github.com/blackgan3"},"pages":[],"posts":[{"title":"nodejs基本语法","slug":"nodejs基本语法","date":"2018-03-21T13:08:30.000Z","updated":"2018-03-21T13:08:30.191Z","comments":true,"path":"2018/03/21/nodejs基本语法/","link":"","permalink":"http://github.com/blackgan3/2018/03/21/nodejs基本语法/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JavaScript闭包","slug":"JavaScript闭包","date":"2018-03-21T13:08:13.000Z","updated":"2018-03-21T13:08:13.725Z","comments":true,"path":"2018/03/21/JavaScript闭包/","link":"","permalink":"http://github.com/blackgan3/2018/03/21/JavaScript闭包/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JavaScript中函数参数传递","slug":"JavaScript中函数参数传递","date":"2018-03-21T13:08:01.000Z","updated":"2018-03-21T13:08:01.296Z","comments":true,"path":"2018/03/21/JavaScript中函数参数传递/","link":"","permalink":"http://github.com/blackgan3/2018/03/21/JavaScript中函数参数传递/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JavaScript中的事件委托机制","slug":"JavaScript中的事件委托机制","date":"2018-03-21T13:07:39.000Z","updated":"2018-03-21T13:07:39.081Z","comments":true,"path":"2018/03/21/JavaScript中的事件委托机制/","link":"","permalink":"http://github.com/blackgan3/2018/03/21/JavaScript中的事件委托机制/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JavaScript中的this指向问题","slug":"JavaScript中的this指向问题","date":"2018-03-21T13:07:09.000Z","updated":"2018-03-21T13:07:09.549Z","comments":true,"path":"2018/03/21/JavaScript中的this指向问题/","link":"","permalink":"http://github.com/blackgan3/2018/03/21/JavaScript中的this指向问题/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"从JavaScript的事件循环到Promise","slug":"从JavaScript的事件循环到Promise","date":"2018-03-21T11:55:43.000Z","updated":"2018-03-21T12:06:27.045Z","comments":true,"path":"2018/03/21/从JavaScript的事件循环到Promise/","link":"","permalink":"http://github.com/blackgan3/2018/03/21/从JavaScript的事件循环到Promise/","excerpt":"","text":"12371728391729","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-03-21T11:44:28.781Z","updated":"2018-03-21T11:44:28.781Z","comments":true,"path":"2018/03/21/hello-world/","link":"","permalink":"http://github.com/blackgan3/2018/03/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Angularjs指令","slug":"Angularjs指令","date":"2016-06-10T12:50:30.000Z","updated":"2018-03-21T13:06:47.996Z","comments":true,"path":"2016/06/10/Angularjs指令/","link":"","permalink":"http://github.com/blackgan3/2016/06/10/Angularjs指令/","excerpt":"ng通过指令这个新属性来扩展html,angular通过内置的指令来为新应用添加功能,允许你自定义指令,ng-app初始化一个ng应用程序,ng-model将元素值绑定到应用程序.","text":"ng通过指令这个新属性来扩展html,angular通过内置的指令来为新应用添加功能,允许你自定义指令,ng-app初始化一个ng应用程序,ng-model将元素值绑定到应用程序.ng-repeat指令会重复一个HTML元素,例子:12345678910&lt;div ng-app=&quot;&quot; ng-init=&quot;names=[&apos;Jani&apos;,&apos;Hege&apos;,&apos;Kai&apos;]&quot;&gt; &lt;p&gt;使用 ng-repeat 来循环数组&lt;/p&gt; &lt;ul&gt; &lt;li ng-repeat=&quot;x in names track by $index&quot;&gt; &#123;&#123; x &#125;&#125; &lt;/li&gt; &lt;/ul&gt;//track by $index加上这个就是可以提高性能,并且还可以使用重复的数组中的值输出&lt;/div&gt; ng-class是可以接受一些表达式的,经过封装和增强:和原本的设置class的情况有了一定的区别,使用实例:1&lt;div ng-class=&apos;&#123;error:isError,warning:isWarning&#125;&apos;&gt;&#123;&#123;messsage&#125;&#125;&lt;/div&gt; 这里呢我们在控制器中可以改变isError和isWarning的值是为false还是为true,哪一个为true就去赋值为哪一个样式.ng-show还有ng-hide:ng-Animate:是用来是实现动画的额.自定义指令:我们使用能促进重用的技术是将数据绑定表达式放在一个指令中,要创建一个指令,首先要定位指令要被放入的目标模块,并调用它的directive()函数,和controller一样,指令时注册在module上,不同在于指令通过module.directiveAPI来注册,module.directive接受的是一个规范化的名字和工厂函数,这个工厂函数返回一个包含不同配置的对象,这个对象用来告诉$compile服务如何进行下一步处理,工厂函数仅在编译器第一次匹配到指令的时候调用一次,通常在工厂函数中执行初始化的工作,该函数使用$injector.invoke调用,所以它可以像controller一样进行依赖注入,优先返回一个定义好的对象,而不是返回一个函数,可以使用.directive函数来添加自定义指令.要调用自定义指令，HTML 元素上需要添加自定义指令名。使用驼峰法来命名一个指令， runoobDirective, 但在使用它时需以 - 割, runoob-directive:下边的例子中定义一个指令:这个directive()函数接受指令的名字和一个函数,123456789&lt;script&gt;var app = angular.module(&quot;myApp&quot;, []);app.directive(&quot;runoobDirective&quot;, function() &#123; return &#123;restrict:&quot;A&quot;, template : &quot;&lt;h1&gt;自定义指令!&lt;/h1&gt;&quot; &#125;; &#125;); &lt;/script&gt; 调用指令的时候,我们可以使用元素名进行调用,进行调用,还可以通过属性的方式进行调用,还可以通过类名进行调用,还可以通过注释的方式进行调用,当前,你也可以限定调用的方式为特定的,这是通过restrict属性来进行特定的调用设置,实例如上一个程序中添加的那样,它的不同的值代表着不同的调用方式,E(element)作为元素名使用,A(attribute)作为属性使用,C(class)作为类名使用,M(comments)作为注释使用,restrict的默认值为EA,可以通过属性名和元素名来调用指令,一般推荐这样使用angularJS:是基于模块的框架,因此上来要创建一个自己的模块,1var myAppModule = angular.module(&quot;myApp&quot;,[]); 然后再模块上创建指令directive:1234567myApp.directive(&quot;xio&quot;,funciton()&#123;return &#123;restrict:&apos;asdc&apos;,template:&apos;&lt;div&gt;hello my directive&lt;/div&gt;&apos;,replace:true;&#125;&#125; 函数return了一个键值对组合,其中定义了标签的使用方法,属性等等内容, restrict:定义了标签的使用方法,一共四种,AECM 如果想要注释起作用,需要将replace属性设置为true;注释中指令要留有空格template:定义了标签的模板,里边是用于替换自定义标签的字符串, replace: 是否支持替换,默认为false,即为不支持当前的被替换掉 transclude:是否支持内嵌.当前的元素节点是否支持template中的内容进行内嵌 templateUrl:’hello.html’; templateCache;用来缓存模板 scope:{}用于创建一个子scope或孤立的scope,默认为false,true时会从父作用域继承并创建一个自己的作用域,而ng-controller的作用也是从父作用域继承并创建一个新作用域, link:用于dom操作任务的函数 link函数接受三个参数: scope:它代表指令被使用的作用域,在上面的例子中它等同与控制器的作用域指的是template中的作用域 elem:它代表绑定指令的元素的jQlite包裹元素,该元素已经被jQuery包裹,所以我们没有必要将它包含在$()中来进行DOM操作,*attars:它代表绑定指令的元素上的属性: priority:优先级,在同一个元素上声明了多个指令时,根据优先级决定哪个被调用,如果pritoty相同,则按照声明顺序调用,另外,no-repeat是所有内置指令中优先级最高的, 隔离指令的作用域:上边我们定义的xio指令已经非常好了,但是它有个致命的缺陷,我们在给定的作用域中仅能使用一次,现在的实现是,我们每次重用该指令的时候都要为它新创一个控制器,我们想要做的是能够把指令的作用域与外部的作用域隔离开来,然后映射到外部的作用域,可以通过创建isolateScope来完成这个目的,这样我们使用指令的scope配置 指令的内嵌使用:因为标签内部可以嵌套其他的标签,因此想要在自定义标签中嵌套其他标签,则需要:1,使用transclude属性,并设置为true2,并使用ng-transclude属性,定义内部嵌套的位置1234567myAppModule.directive(&quot;test&quot;,function()&#123; return&#123; restrict:&apos;AECM&apos;, transclude:true, template:&quot;&lt;div&gt;haha! &lt;div ng-transclude&gt;&lt;/div&gt; wuwu!&lt;/div&gt;&quot; &#125; &#125;);","categories":[],"tags":[]},{"title":"ajax详解","slug":"ajax详解","date":"2016-05-10T11:27:10.000Z","updated":"2018-03-21T13:00:47.535Z","comments":true,"path":"2016/05/10/ajax详解/","link":"","permalink":"http://github.com/blackgan3/2016/05/10/ajax详解/","excerpt":"ajax详解 ajax(Asynchronous Javascript AndXML)即为异步的JavaScript和XML,顾名思义,这个技术是和我们当前页面刷新无关的,因为它是异步的,在没有ajax的时候,我们如果去请求数据库中的数据就要将当前页面进行刷新,最常用的你可以想到我们的表单验证部分,以前都是填完了所有的表单去一次性验证,像这样的注册界面,你填错了就要刷新页面从头再来,所以,现在有了ajax你可以填一个表格就进行一次验证,而且页面并不会刷新.","text":"ajax详解 ajax(Asynchronous Javascript AndXML)即为异步的JavaScript和XML,顾名思义,这个技术是和我们当前页面刷新无关的,因为它是异步的,在没有ajax的时候,我们如果去请求数据库中的数据就要将当前页面进行刷新,最常用的你可以想到我们的表单验证部分,以前都是填完了所有的表单去一次性验证,像这样的注册界面,你填错了就要刷新页面从头再来,所以,现在有了ajax你可以填一个表格就进行一次验证,而且页面并不会刷新. 对于ajax,他的核心技术是对象,它的整个作用过程其实是当前页面继续工作,它会自己开一个时空隧道和当前界面一起工作,就行两个平行空间一样,它的整个过程可以总结为先创建XMLHttpRequest对象,然后连接服务器,发送请求,最后接受服务器发送过来的数据,好了,XMLHttpRequest是一个可以让我们前端和后端连接起来的十分神奇的对象,我们首先来创建一个XMLHttpRequest对象 复制代码123456789 var xhr =null; if(window.XMLHttpRequest)&#123; xhr = new XMLHttpRequest(); &#125;else&#123; xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); &#125;//这里进行的是针对IE浏览器的兼容性处理,在IE中,我们的xmlhttprequest对象就变成了activeobject,而且里边的参数是不能少的,IE就是这样倔强复制代码 当我们拥有了一个xhr实例后,我们就可以进行向数据库中发送请求,这里我们先来看一下我们需要用的方法,open()方法是建立前端到服务器的请求,而send方法是向服务器发送请求,也就是说,当我们在叫外卖的时候,我们用的美团就像是open()方法,建立我们和店家的联系,而快递小哥就是我们的send()方法,他将我们的美味给我们送过来,这里我们先用get方法做一个示例,在下一块我们再区看一下我们的两种请求方法get和se的区别:123var url =&quot;index.php?id=1&quot;;xhr.open(&apos;get&apos;,url,&apos;true&apos;);//open中有三个参数,第一个参数用来指定使用get还是post方式提交,第二参数是指定要发送的url地址,第三个参数指定是否使用异步,第三个参数默认是true;xhr.send(); 这是我们已经使用get方式向index.php发送了一个请求,我们穿过去的参数为”id=1”;那么我们先来看一下和get和post区别,get和post都是用来进行发送数据的方式,从字面意思来看,get(得到)是从数据库得到东西的请求方式,而post(发送)是要给服务器传送数据的,而且post方式传送数据是经过加密的,post传送的数据放在请求体里边,而get方式只有请求头,没有请求体,所以get也可以传给数据库少量数据,发送的方式是在url地址后边用?做表示,如果有多个参数用&amp;隔开,我们先来看一下post的用法: 12345var url = &quot;index.php&quot;;var data = &quot;id=1&quot;;xhr.open(&apos;post&apos;,url,true);xhr.setRequestHeader(&apos;Contenttype&apos;,&apos;application/x-www-form-urlencoded&apos;)//post请求需要设置请求头信息xhr.send(data);//在这里将数据发送过去, 那么现在我们已经简单的向服务器端发送了请求,我们正常的一个流程是,服务器会根据我们的参数或者是它自身运算的结果来给我们返回数据,这里我们并不是一定要发送给数据库参数的,举个例子,服务器里有一个数组[“0”:”苹果”,”1”:”橘子”,”2”:”香蕉”],现在如果我们不传参,服务器会将这一个数组都return给我们,如果我们穿一个id=1,这时返回的数据就是橘子,我们要理解的就是,我们传的参数和数据对于我们获得数据只是一个辅助作用,真正起作用的还是服务器内部的结构,那么我们现在发送了请求后,我们面临一个问题,我们怎么判断请求是否发送成功以及服务器时候处理了我们的请求,还有如果服务器响应了,它返给我们的数据我们该怎么去获取呢? 好的,让我们来看一下,xhr实例上有一个readystate属性,这个属性的代表着当前xmlHttpRequest的状态: 0:请求没有发出(在调用open之前) 1:请求已经建立但还没有发出 2:请求已经发出 3:请求正在处理当中 4:请求已经被服务器处理完毕,相应准备就绪 每当readystate状态改变的时候,就会调用onreadystatechange()这个函数,所以我们可以在onreadystatechange进行相应状态的判断以及相应返回数据的获取,当readystate为4时,代表着我们的请求被服务器成功的执行,但我们还需要判断,我们的需要的数据是否成功被返回了呢?我们还有一个status属性,而这个status也有很多的状态码代表着不同的响应状态,其中200代表着响应成功,并且将响应的数据返回到了前端中: 1234567xhr.onreadystatechange = function()&#123; if(xhr.readystate == 4)&#123;//请求已经成功被处理 if(xhr.status == 200)&#123;//成功的从服务器得到了响应 //这里进行处理返回的数据 &#125; &#125;&#125; 得到了响应之后,responseText表示字符串形式的相应数据,responseXML表示获取XML形式的响应数据,getAllResponseHeader():获取所有的响应报头,这里我们来完整的写一个ajax请求: 123456789101112131415161718var xhr =null; if(window.XMLHttpRequest)&#123; xhr = new XMLHttpRequest(); &#125;else&#123; xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); &#125; var url =&quot;index.php?id=1&quot;; xhr.open(&apos;get&apos;,url,&apos;true&apos;);//open中有三个参数,第一个参数用来指定使用get还是post方式提交,第二参数是指定要发送的url地址,第三个参数指定是否使用异步,第三个参数默认是true; xhr.send(); xhr.onreadystatechange = function()&#123; if(xhr.readystate == 4)&#123;//请求已经成功被处理 if(xhr.status == 200)&#123;//成功的从服务器得到了响应 alert(responseText); &#125; &#125; &#125;相应的后端会在后边用php实现一个小的demo 二,XML和json 当我们完成了发送请求并且从后端获取了数据后,我们应该再进一步的去思考,那么我可以指定从后端传过来的数据吗?那么接下来就出现了我们的json和XML数据格式,这两种都是我们进行前端和后端进行传送数据的格式,那么我们先来看一下XML,XML数据其实你也可以看做我们的html标签,只不过它是我们可以自定义的标签,你可以给它的标签名取的很有意义,那样就会很方便你去使用: 12345678&lt;china&gt; &lt;province name=&apos;河南&apos;&gt; &lt;city&gt;郑州&lt;/city&gt; &lt;/province&gt; &lt;/china&gt;//这就是一个简单的XML格式的数据,我们对于这样的数据进行操作的时候可以使用js操作DOM对象的方法,//xml数据必须有一个根节点 另外一种经常使用的数据格式就是json了,json是一种独立于语言的数据格式,就是说它是可以在很多种语言中使用的,不限定于某一个特定的语言,而且它相较于xml来说代码量较小,而且易于解析,xml就有些数据量庞大解析不便了,但是碍于json出现的较晚,所以现在大部分人还是使用的xml,无奈与很多后端数据都是用xml存储,json的格式有些类似于我们的JavaScript中的对象字面量: 12345&#123;&quot;name&quot;:&quot;james&quot;, &quot;hobby&quot;:&quot;basketball&quot;, &quot;son&quot; : &#123;&quot;littleson&quot;:&quot;er&quot;,&quot;bigson&quot;:&quot;san&quot;&#125;&#125;//这种就是一个简单的json格式数据,json数据代码量较小,但是可读性来说还是xml看着比较顺眼,但是人看着不顺眼的代码块恰恰是机器最喜欢的 得到了数据,我们还需要去解析一下才能够使用,相较于xml有些dom一样的解析方法,xml的解析在js中最长用的解析方法就是json.parse()了,而将js对象转化为json对象我们使用json.stringify(),当然了,json和xml的区别还有很多,这里我献上一个前辈的总结,很详细的一个总结: http://www.cnblogs.com/SanMaoSpace/p/3139186.htm 三,ajax在jQuery中 那么我们之前已经看了ajax在js中的应用,jQuery号称是js的最强悍的一个封装库,怎能没有ajax的封装呢?我们先来简略的看一下jQuery源码中对于ajax的封装: 123456//它的大概位置在七千行左右jQuery.extend(&#123; ajax: function( url, options )&#123;&#125;&#125;);//从这个大概形式中,我们可以看得出来,ajax时封装在jQuery的工具方法中,是在jQuery上直接封装的,所以调用的时候直接使用jQuery这个函数就行,所以我们对于它的调用就是$.ajax(); 那么我们还是写一个简单的post请求方式在jQuery中的应用: 123456789101112131415 $.ajax(&#123; type:&quot;post&quot;, //请求方式 url:&quot;a.php&quot;, //服务器的链接地址 dataType:&quot;json&quot;, //传送和接受数据的格式 data:&#123; username:&quot;james&quot;, password:&quot;123456&quot; &#125;, success:function(data)&#123;//接受数据成功时调用的函数 console.log(data);//data为服务器返回的数据 &#125;, error:function(request)&#123;//请求数据失败时调用的函数 alert(&quot;发生错误:&quot;+request.status); &#125;&#125;); 有了post请求方式的例子,想必get方式的写法大家也不在话下,看着jQuery的例子,是不是感觉很简单呢,很多兼容性的处理jQuery都已经帮我们做好了,就是这个feel. 四,跨域请求 在上边的例子中,我们使用ajax请求的都是在本地和我们同源的文件,因为JavaScript在设计时出于安全方面的考虑,不允许跨域请求,那么什么情况才算是跨域呢? 上边的就是我们的不同源的情况,遇到这种情况,再去使用上边所讲的方式就不行了,那么我们该怎样去解决跨域请求的问题呢?JSONP(JSON with Padding)是 JSON 的一种“使用模式”，可用于解决主流浏览器的数据访问问题,因为html的元素标签可以从其他来源动态的加载数据,所以我们可以利用标签来实现跨域请求,这种方式就成为jsonp,当然了,jsonp和json可不是一回事,json是数据的一种传输格式,而jsonp是一种跨域请求方式,简单的理解就是: 123456&lt;html&gt;&lt;body&gt; &lt;script src=&apos;test.js&apos;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;//script中的src没有同源限制,它可以加载其他任意文件.而jsonp利用的就是这一个功能展开的 对于jsonp这种跨域请求方式,我们首先先来写一个例子,然后再根据这个例子去慢慢的介绍: 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;jsonp&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;http://cdn.weather.hao.360.cn/api_weather_info.php?app=hao360&amp;_jsonp=weather&amp;code=131111&quot;&gt;&lt;/script&gt;//这是360天气的一个天气预报的一个api接口,&lt;/body&gt;&lt;/html&gt; 当我们运行上边例子后,在chrome浏览器中打开开发者模式-&gt;点击network-&gt;查看请求包-&gt;点击response,这时我们可以查看到: 是的这时候远方的数据库中向我们返回了一大串数据,仔细观察的话,不难发现,这一串数据的格式就是weather( 数据 );咦,这不是一个weather函数调用吗?是的,没错,我们的数据库向我们返回的就是一个函数调用,在看一下,我们script中的url地址后边的参数_jsonp=weather,我们将它改为tianqi发现返回的是一个tianqi().哦,原来_jsonp参数是指定服务器返还给我们的函数名,那么函数中的参数就是服务器返还给我们的数据,那么我们也发现此时浏览器已经报错了: 那么也就是说我们的代码中没有weather这个函数,加上上边的讲解,我们这时应该去直接的说一下它的运行机制了,执行完script中的跨域调用后,会直接调用weather函数,所以这时候我们要再代码中写一个为weather函数让script来执行,那么weather函数中的参数就是我们要的数据,我们这时就可以在weather函数中直接使用我们的数据了,这里还要说明一点,jsonp只有get请求方式,也就是传参都要再url后边,而且其中的数据传输格式都为json, 123456&lt;script&gt; function weather(data)&#123;//回调函数 console.log(data); &#125;&lt;/script&gt;&lt;script src=&quot;http://cdn.weather.hao.360.cn/api_weather_info.php?app=hao360&amp;_jsonp=weather&amp;code=111111&quot;&gt;&lt;/script&gt; 这时我们就可以看到结果: 在这里我们使用jsonp调用数据时,我们需要先去了解一下后台数据的格式,因为我们要去传一些参数进行获取数据,所以前端后端是不分家的,那么我们当天也可以使用动态加载script标签的方法来进行点击按钮获取数据 123456function createScript()&#123; var script = document.createElement(&apos;script&apos;); var url = &quot;http://cdn.weather.hao.360.cn/api_weather_info.php?app=hao360&amp;_jsonp=weather&amp;code=&quot;; script.src = url+params; document.body.appendChild(script); &#125;//使用这个函数就可以动态的加载数据了 那么下边我们来看一下jQuery中jsonp的使用: 12345678910111213$.ajax(&#123; type:&apos;get&apos;, url:天气预报接口, async:&apos;true&apos;, // 是否为异步调用 dataType:&apos;jsonp&apos;, 指定数据传输方式 jsonp:&apos;jsoncallback&apos;, //回调函数名的key值 可省略 jsonpCallback:&apos;XBox&apos;, //回调函数的函数名 可省略 success:function(data)&#123; //成功后执行的函数,data就是我们要获取的函数值 &#125;, error :function()&#123; //失败时执行的函数 &#125; 获得数据我们可以显示在HTML标签中,有了这种异步调用方式,我们就可以去做一些很好玩的东西了,什么天气预报,快递查询,音乐播放器了,都不在话下,当然,跨域调用还有很多种,但我就对jsonp使用的多一点,其他中方法就不提啦,文章中可能会有一些知识点被漏掉,毕竟是自己的一个小总结,希望能对大家有点小帮助.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://github.com/blackgan3/tags/javascript/"},{"name":"ajax","slug":"ajax","permalink":"http://github.com/blackgan3/tags/ajax/"}]}]}