{"meta":{"title":"Blackgan","subtitle":null,"description":"只要这一秒不失望,下一秒就还有希望","author":"Blackgan","url":"http://github.com/blackgan3"},"pages":[],"posts":[{"title":"从JavaScript的事件循环到Promise","slug":"从JavaScript的事件循环到Promise","date":"2018-03-21T11:40:08.000Z","updated":"2018-03-23T08:25:38.608Z","comments":true,"path":"2018/03/21/从JavaScript的事件循环到Promise/","link":"","permalink":"http://github.com/blackgan3/2018/03/21/从JavaScript的事件循环到Promise/","excerpt":"JS线程是单线程运行机制，就是自己按顺序做自己的事，浏览器线程用于交互和控制，JS可以操作DOM元素，","text":"JS线程是单线程运行机制，就是自己按顺序做自己的事，浏览器线程用于交互和控制，JS可以操作DOM元素， 说起JS中的异步时，我们需要注意的是，JS中其实有两种异步，一种是基于浏览器的异步IO，比如Ajax，另外一种是基于计时方法setTimeout和setInterval的异步。 对于异步IO，比如ajax，写代码的时候都是顺序执行的，但是在真正处理请求的时候，有一个单独的浏览器线程来处理，并且在处理完成后会触发回调。这种情况下，参与异步过程的其实有2个线程主体，一个是javascript的主线程，另一个是浏览器线程。 熟悉Javascript的人都知道，Javascript内部有一个事件队列，所有的处理方法都在这个队列中，Javascript主线程就是轮询这个队列处理，这个好处是使得CPU永远是忙碌状态。这个机制和Windows中的消息泵是一样的，都是靠消息（事件）驱动， 对于setTimeout和setInterval来说，当js线程执行到该代码片段时，js主线程会根据所设定的时间，当设定的时间到期时，将设置的回调函数放到事件队列中，然后js主线程继续去执行下边的代码，当js线程执行完主线程上的代码之后，会去循环执行事件队列中的函数。至于setTimeout或者setInterval设定的执行时间在实际表现时会有一些偏差，普遍的一个解释为，当定时任务的时间到期时，本应该去执行该回调函数，但是这时js主线程可能还有任务在执行，或者是该回调函数再事件队列中排的比较靠后，就导致该回调函数执行时间与定时器设定时间不一致。 那么问题来了，什么是事件队列？ eventloop是一个用作队列的数组,eventloop是一个一直在循环执行的，循环的每一轮成为一个tick,在每一个tick中，如果队列中有等待事件，那么就会从队列中摘取下一个事件进行执行，这些事件就是我们之前的回调函数。现在ES6精确指定了事件循环的工作细节，这意味着在技术上将其纳入了JavaScript引擎的势力范围，而不只是由宿主环境决定了，主要的一个原因是ES6中promise的引入。1234567891011121314var eventloop = []var event;while(true)&#123; if(eventloop.length&gt;0)&#123; //拿到队列中的下一个事件 event = eventloop.shift(); //现在执行下一个事件 try&#123; event(); &#125;catch(e)&#123; reportError(e); &#125; &#125;&#125; 在浏览器端，setTimeout中的最小时间间隔是W3C在HTML标准中规定，规定要求低于4ms的时间间隔算为4ms。 任何时候，只要把一个代码包装成一个函数，并指定它在响应某个事件时执行，你就是在代码中创建了一个将来执行的模块，也由此在这个程序中引入了异步机制。 js引擎并不是独立运行的，它运行在宿主环境中，就是我们所看到的Web浏览器，当然，随着js的发展，包括最近的Node，便是给js提供了一个在服务器端运行的环境。并且现在的js还嵌入到了机器人到电灯泡的各种各样的设配中。 但是这些所有的环境都有一个共同的“点”，即为都提供了一种机制来处理程序中的多个块的执行，且执行每个块时调用JavaScript引擎，这种机制被称为事件循环。 js引擎本身并没有时间的概念，只是一个按需要执行JavaScript任意代码片段的环境。 对于js中的回调，我们最常见的就是链式回调和嵌套回调我们经常再ajax中嵌套ajax调用然后再嵌套ajax调用，这就是回调地狱，回调最大的问题就是控制反转，它会导致信任链的完全断裂，为了解决回调中的控制反转问题，有些API提供了分离回调（一个用于成功通知，一个用于失败通知），例如ajax中的success函数和failure函数，这种情况下，API的出错处理函数failure()常常是可以省略的，如果没有提供的话，就是假定这个错误可以吞掉。 还有一种回调模式叫做“error-first”风格，其中回调的第一个参数保留用作错误对象，如果成功的话，这个参数就会被清空/置假。 回调函数是JavaScript异步的基础单元，但是随着JavaScript越来越成熟，对于异步领域的发展，回调已经不够用了。 PromisePromise 是异步编程中的一种解决方案，最早由社区提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。 Promise是一种封装和组合未来值的易于复用的机制。一种在异步任务中作为两个或更多步骤的流程控制机制，时序上的this-then-that. 假定调用一个函数foo(),我们并不需要去关心foo中的更多细节，这个函数可能立即完成任务，也可能过一段时间才去完成。对于我们来讲，我们只需要知道foo()什么时候完成任务，这样我们就可以去继续执行下一个任务了，在传统的方法中，我们回去选择监听这个函数的完成度，当它完成时，通过回调函数通知我们，这时候通知我们就是执行foo中的回调，但是使用promise时，我们要做的是侦听来自foo的事件，然后在得到通知的时候，根据情况而定。 其中一个重要的好出就是，我们可以把这个事件中的侦听对象提供给代码中多个独立的部分，在foo()完成的时候，他们都可以独立的得到通知: 12345var evt = foo();//让bar()侦听foo()的完成bar(evt);//让baz()侦听foo()的完成baz(evt); 上边的例子中，bar和baz中不需要去知道或者关注foo中的实现细节。而且foo也不需要去关注baz和bar中的实现细节。 同样的道理，在promise中，前面的代码片段会让foo()创建并返回一个Promise实例，而且在这个Promise会被传递到bar()和baz()中。所以本质上，promise就是某个函数返回的对象。你可以把回调函数绑定再这个对象上，而不是把回调函数当成参数传进函数。1234const promise = doSomething();promsie.then(successCallback,failureCallback)&#123; &#125; 当然啦，promise不像旧式函数将回调函数传递到两个处理函数中，而且会有一个优点： 在JavaScript事件队列的本次tick运行完成之前，回调函数永远不会执行。 通过.then形式添加的回调函数，甚至都在异步操作完成之后才被添加的函数，都会被调用。 通过多次调用.then，可以添加多个回调函数，他们会按照插入顺序并且独立运行。 但是，Promise最直接的好出就是链式调用。 12345678910doSomething().then(function(result) &#123; return doSomethingElse(result);&#125;).then(function(newResult) &#123; return doThirdThing(newResult);&#125;).then(function(finalResult) &#123; console.log('Got the final result: ' + finalResult);&#125;).catch(failureCallback); 并且在一个失败操作之后还可以继续使用链式操作，即使链式中的一个动作失败之后还能有助于新的动作继续完成。 在调用Promise中的resolve()和reject()函数时如果带有参数，那么他们的参数会被传递给回调函数。 Promise.resolve()和Promise.reject()是手动创建一个已经resolve或者reject的promise快捷方法。通常，我们可以使用Promise.resolve()去链式调用一个由异步函数组成的数组。例如：1Promise.resolve().then(func1).then(func2); Promise.all()和Promise。race()是并行运行异步操作的两个组合式工具。 Promise.then()方法用来分别指定resolved状态和rejected状态的回调函数。传递到then中的函数被置入了一个微任务队列，而不是立即执行，这意味着它是在JavaScript事件队列的所有运行结束了，事件队列被清空之后才开始执行123456789101112131415let promise = new Promise(function(resolve, reject) &#123; console.log('Promise'); resolve();&#125;);promise.then(function() &#123; console.log('resolved.');&#125;);console.log('Hi!');// Promise// Hi!// resolved Promise.then()方法返回一个Promise,它最多需要有两个参数：Promise的成功和失败情况的回调函数。1234567p.then(onFulfilled, onRejected);p.then(function(value) &#123; // fulfillment &#125;, function(reason) &#123; // rejection&#125;); onFulfilled:当Promise变成接受状态(fulfillment)时，该参数作为回调函数被调用。该函数有一个参数，即接受的值。 onRejected:当Promise变成拒绝状态时，该参数作为回调函数被调用。该函数有一个参数，即拒绝的原因。 Promise的状态一旦改变，就永久保持该状态，不会再改变了。 Promise中的错误处理一般的情况，我们会在每次的Promise中抛出错误，在Promise中的then函数中的rejected处理函数会被调用，这是我们作为错误处理的常用方法：12345678910 let p = new Promise(function(resolve,reject)&#123; reject('error'); &#125;); p.then(function(value)&#123; success(value); &#125;,function(error)&#123; error(error) &#125;) 但是一种更好的方式是使用catch函数，这样可以处理Promise内部发生的错误，catch方法返回的还是一个Promise对象，后边还可以接着调用then方法。而且catch方法尽量写在链式调用的最后一个，避免后边的then方法的错误无法捕获。123456789let p = new Promise(function(resolve,reject)&#123; reject('error'); &#125;); p.then(function(value)&#123; success(value); &#125;).catch(function(error)&#123; console.log('error'); &#125;&#125; Promise.finally()函数，该方法是ES2018引入标准的。指定不管Promise对象最后状态如何，都会执行的操作。finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的Promise状态到底是fulfilled还是rejected。这标明，finally方法里面的操作，是与状态无关的，不依赖于Promise的执行结果。 上述文章，如有错误，还请指正，谢谢！！！ 参考 阮一峰老师的ES6 MDN中的Promise","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://github.com/blackgan3/tags/ES6/"}]},{"title":"ES6中的Generator函数","slug":"ES6中的Generator函数","date":"2018-02-23T07:44:42.000Z","updated":"2018-03-23T08:25:19.505Z","comments":true,"path":"2018/02/23/ES6中的Generator函数/","link":"","permalink":"http://github.com/blackgan3/2018/02/23/ES6中的Generator函数/","excerpt":"generator是什么？generator是ES6提供的一种异步编程解决方案，在语法上，可以把它理解为一个状态机，内部封装了多种状态。执行generator，会生成返回一个遍历器对象。返回的遍历器对象，可以依次遍历generator函数的每一个状态。同时ES6规定这个遍历器是Generator函数的实例，也继承了Genarator函数的prototype对象上的方法。","text":"generator是什么？generator是ES6提供的一种异步编程解决方案，在语法上，可以把它理解为一个状态机，内部封装了多种状态。执行generator，会生成返回一个遍历器对象。返回的遍历器对象，可以依次遍历generator函数的每一个状态。同时ES6规定这个遍历器是Generator函数的实例，也继承了Genarator函数的prototype对象上的方法。 最简单的generator函数,其实它就是一个普通的函数，但是它有两个特征。第一就是function关键字与函数名之间有一个*号，其二就是函数体内使用yield表达式来遍历状态：12345function* newGenerator()&#123; yield 'hello'; yield 'world'; return 'ending';&#125; 执行generator函数之后，该函数并不会立即执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象。通常使用遍历器对象的next方法。使得指针移向下一个状态。每一次调用next()方法，内部指针就从函数头部或上一次停下里的地方开始执行，直到遇到下一个yield表达式位置，由此可以看出，generator是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。 generator中的yield表达式yield表达式在generator中是作为一个暂停标志，当碰到yield时，函数暂停执行，等到下一次next()执行时，函数才从当前yield位置开始执行。并且，yield表达式只能用在Generator函数里边；同时，yield如果后边带一个,则就是相当于一个for…of的简写形式，如果yield后边不带,则返回的是generator的值。12345678910function* gen() &#123; yield 'hello'; yield* 'hello';&#125;let f = gen();console.log(f.next().value);console.log(f.next().value);console.log(f.next().value);console.log(f.next().value);console.log(f.next().value); 上述例子中的后四个next()函数，就会顺序的返回h e l l generator中的next函数通过next函数，可以执行对应的yield表达式，且next()函数还可以带参数，该参数可以作为上一次yield表达式的返回值，因为yield本身是没有返回值的，如果next()中不带参数，则yield每次运行之后的返回值都是为undefined;1234567891011121314function* dataConsumer() &#123; console.log('Started'); console.log(`1. $&#123;yield&#125;`); console.log(`2. $&#123;yield&#125;`); return 'result';&#125;let genObj = dataConsumer();genObj.next();// StartedgenObj.next('a');// 1. agenObj.next('b');// 2. b 上述函数中，第一次运行next()，运行到第一个next()函数截止，第二个next运行时，传入的参数为’a’;则运行到第二个yield地方截止，然后第一个yield运行的返回值为’a’,依次类推，则得到上述结果。 另外，通过for…of可以循环generator中的所有状态，并且不需要使用next()函数。除了for…of循环以外，扩展运算符(…),解构赋值和Array.form方法内部调用的，都是遍历器接口。 generator生成的对象，还有其他一些函数，比如throw()用来抛出错误，return()用来定义返回值并终止generator的状态。 以上的三个方法在本质上其实是一样的，他们就是让generator恢复执行，并且使用不同的语句来替代yield语句。 next()是将yield表达式替换成一个值 throw()是将yield表达式替换成一个throw语句 return()是将yield表达式替换成一个return语句 Generator与协程协程可以理解为“协作的线程”或者“协作的函数”。协程既可以是单线程实现，也可以用多线程实现，前者是一种特殊的子例程，后者是一种特殊的线程。 协程有点像函数，又有点像线程，它的运行流程大致如下。 第一步，协程A开始执行 第二部，协程A执行到一半，进入暂停，执行权转移到协程B 第三步，（过了一段时间）协程B交换执行权 最后，协程A恢复执行 协程适合用于多任务运行环境，它与普通的线程很相似，都有自己的执行上下文，可以分享全局量。他们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都是处于暂停状态。 由于JavaScript是单线程，只能保持一个调用栈，引入协程之后，每一个任务可以保持自己的调用栈，这样就可以再抛出错误的时候找到原始的调用栈，不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束了。 Generator 函数是 ES6 对协程的实现，但属于不完全实现。Generator函数被称为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。 如果将Generator函数当做协程，完全可以将多个需要互相协作的任务写成Generator函数，他们之间使用yield标识交换控制权。 Generator 函数执行产生的上下文环境，一旦遇到yield命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行next命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。 Generator函数的多种用途 可以使异步操作来实现同步化表达 控制流管理 部署Iterator接口 做为数据结构 上述的介绍中，我们看到了generator是什么，下边我们看一下，目前中，我们使用最多的，generator函数的异步调用。 异步编程对于单线程的JavaScript无疑是十分重要的（可以笼统的将异步定义为不连续的执行）。之前的文章中，我们也说过，JavaScript中对于异步的实现，就是回调函数。我们之前也有使用过promise去进行死亡回调的改良，promise来使回调嵌套的表现形式更好了些。其实呢generator函数也可以用来实现异步回调的嵌套。 整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。即为next方法还可以接收参数，向Generator函数体内输入数据。 Thunk函数Thunk函数是自动执行Generator函数的一种方法。 对于以前的函数参数的求值计算，有两种计算方式，一种是传值调用，一种是传名调用。编辑器中的“传名调用”的实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体，这个临时函数就叫做Thunk函数。 JavaScript中使用的是传值调用，它的Thunk函数含义有所不同。再JavaScript中，替换的不是表达式，而是多参数函数的休整。 Thunk函数可以用于Generator函数的自动流程管理。即使Generator函数可以自动执行。 co模块co模块用于Generator函数的自动执行。co函数返回一个Promise对象，因此可以用then方法添加回调函数。 使用了Generator函数之后，我们可以将多个异步嵌套的代码改为同步写异步，大大的简化了我们的代码量，以及代码的美观。 上边就是大概的ES中的Generator函数的介绍，我们可以使用Generator来实现 lazy evaluation，Iterator和实现异步调用同步的写法，但是其中我们面临的更多的还是generator的执行问题，下一篇我们来看一下generator是怎么实现async/await来控制异步。以及co模块的实现。","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://github.com/blackgan3/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://github.com/blackgan3/tags/JavaScript/"}]},{"title":"nodejs环境配置安装","slug":"nodejs环境配置安装","date":"2018-01-23T07:48:49.000Z","updated":"2018-03-23T08:25:19.520Z","comments":true,"path":"2018/01/23/nodejs环境配置安装/","link":"","permalink":"http://github.com/blackgan3/2018/01/23/nodejs环境配置安装/","excerpt":"title: nodejs环境配置安装(nvm)date: 2016-8-20 20:18:39tags: - nodejs - javascript 在我们前端开发工程中,很多繁琐机械的操作都是会慢慢的被抽离出来的,当我们为dom操作和浏览器兼容性感到厌烦时,jQuery出现了,当我们不想再去理会dom的添加删除等的时候,angularJS来解救我们,那么,随着时间的发展,我们前端开发的王牌语言JavaScript,现在被应用到了服务器中,对的,这是一个里程碑式的创新,今后,你不再需要去使用php/.net等后端语言,仅仅使用JavaScript就可以前端后端通吃,这就是web全栈工程师吧!神奇的node.js为我们JavaScript提供了在后端运行","text":"title: nodejs环境配置安装(nvm)date: 2016-8-20 20:18:39tags: - nodejs - javascript 在我们前端开发工程中,很多繁琐机械的操作都是会慢慢的被抽离出来的,当我们为dom操作和浏览器兼容性感到厌烦时,jQuery出现了,当我们不想再去理会dom的添加删除等的时候,angularJS来解救我们,那么,随着时间的发展,我们前端开发的王牌语言JavaScript,现在被应用到了服务器中,对的,这是一个里程碑式的创新,今后,你不再需要去使用php/.net等后端语言,仅仅使用JavaScript就可以前端后端通吃,这就是web全栈工程师吧!神奇的node.js为我们JavaScript提供了在后端运行的环境,而它的包管理器npm(node package manage)现在也成为了全球最大的开源库生态系统.我们有很多很多的工具都是依赖于node环境进行使用的,所以我们使用node的第一步,就是配置node.js环境. 那么配置node.js环境,当然,我们可以直接从官网下载,然后安装到电脑上就行了,当然,这是正确的,但是如果有一天我们需要使用新版本的node.js,或者使用旧版本的node.js时,我们还是需要去官网下载,然后安装,因为node.js的官方对于node.js的版本更新较慢,以至于一些大神等得不耐烦了,便开始自己更新node.js(当然node.js是开源的),你这一更新,导致官方团队坐不住了,那最后的结果就是官方的是稳定版本,当有新功能会在这个版本较高的发布,所以这就是经常会看到 那么我们的解决方法就是安装一个nvm(node version manage)node版本管理控制器,通过 nvm我们可以随意的下载任意版本的node,可以随意切换使用各个版本的node,使用nvm之前,我们先来看一下,我们使用终端打开应用程序的实例:我们使用终端开启一个软件是,必须要cd到这个程序当前所在的文件目录下, 我们可以看到,当前的FlashFXP的链接存在于桌面的上,当我们在桌面中的node.js文件夹中去试图打开它是打不开的,因为我们终端在当前文件夹中找不到FlashFXP的启动程序,所以会报错,那么我们有没有办法去改变这一现象,可以在任何地方,任何文件中启动真个程序呢?当然是可以的,我们只需要配置一下环境变量就可以了,右键我的电脑-&gt;选择属性-&gt;高级系统设置-&gt;环境变量,到了环境变量这,就找对地方了 环境变量是系统中一个特定的对象,当要求系统运行一个程序而且没有告诉系统这个程序的完整路径的时候,系统除了在当前的文件夹下边寻找之外,还会去环境变量中path中指定的路径去寻找,也就是说,如果你将一个文件夹的指定路径保存到了path中,那么每次在终端启动程序时,你根本就不必进去这个程序所在的文件夹也能启动它了,这里我们会看到有系统变量和用户变量,顾名思义,用户变量就是当前登录用户下配置的各种变量,当我们切换用户的时候,这部分的变量是可以变化的,那么这时候我们就需要将想要添加的文件夹添加到用户变量中就行了, 12FLASH= &quot;C:\\Program Files (x86)\\//将当前地址复制到一个变量中,path = %FLASH%;//将这个变量赋值到path中,这时候在任何地方我们都可以打开这个程序了 好了有了上边的铺垫之后,我们就可以来安装nvm了,我们可以使用git直接下载,当然也可以直接去github下载,这里提供一个下载地址,使用手动下载:1https://github.com/coreybutler/nvm-windows/releases 下载图标中的nvm就行,下载完成后解压,然后安装nvm,安装目录地址注意不要有中文,不然指不定会出现什么错误,我这里直接将它安装在了D:\\dev下边,安装完成后一般会去自动给我们配置好系统变量,如果没有,我们需要手动去配置系统变量,原理及方法和我们一开始所讲的一样:123NVM_HOME ：指向nvm安装目录NVM_SYMLINK：nodejs安装目录Path ：变量值中增加 NVM_HOME 和 NVM_SYMLINK两个环境变量 这时我们可以在终端中测试一下:1234567891011121314151617181920212223$ nvm -vRunning version 1.1.0.Usage:nvm arch : Show if node is running in 32 or 64 bit mode.nvm install &lt;version&gt; [arch] : The version can be a node.js version or &quot;latest&quot; for the latest stable version.Optionally specify whether to install the 32 or 64 bit version (defaults to system arch).Set [arch] to &quot;all&quot; to install 32 AND 64 bit versions.nvm list [available] : List the node.js installations. Type &quot;available&quot; at the end to see what can be installed. Aliased as ls.nvm on : Enable node.js version management.nvm off : Disable node.js version management.nvm proxy [url] : Set a proxy to use for downloads. Leave [url] blank to see the current proxy.Set [url] to &quot;none&quot; to remove the proxy.nvm uninstall &lt;version&gt; : The version must be a specific version.nvm use [version] [arch] : Switch to use the specified version. Optionally specify 32/64bit architecture.nvm use &lt;arch&gt; will continue using the selected version, but switch to 32/64 bit mode.nvm root [path] : Set the directory where nvm should store different versions of node.js.If &lt;path&gt; is not set, the current root will be displayed.nvm version : Displays the current running version of nvm for Windows. Aliased as v. //这时就表示nvm安装成功了 这时候我们就可以安装node了,在终端输入命令：nvm ls-remote,用来查看远端的node版本,当然，你可能看不到结果，此时，你就需要输入另一个命令：export NVM_NODEJS_ORG_MIRROR=http:nodejs.org/dist,然后再输入nvm ls -remote,如果还不行,那就去下边这个地址去查看:123https://github.com/coreybutler/nodedistro/blob/master/nodeversions.json 这时候使用命令nvm install [node版本号]等到进度条走完,输入命令 nvm list 来查看当前安装的node 可以看到当前安装的有4.3.1版本,那么我么使用 nvm use 4.3.1就可以指定当前使用的node版本为4.3.1,4.3.2后边也会出现(当前使用的标志),当然,我们可以再去下载一个node版本,例如: 等到进度条走完,这是我们就有了5.7.0和4.3.1两个版本了:这时我们可定是想要去在两个版本之间自如的去切换的,这是我们还需要配置一个文件,就是nvm 中的setting文件: 打开文件进行配置 如上,根据自己的文件目录进行配置,root表示的是当前nvm中内容的地址,path则是需要写入环境变量中的地址path中,会在当天dev/ 文件下生成一个nodejs快捷方式,来作为指向当前使用的node版本的快捷方式,如图所示, 当我们配置好了之后,就可以进行node版本的切换了: 这是我们会发现dev文件中生成了一个nodejs的快捷方式,点击这个快捷方式,就可以调转到当前使用版本的nodejs中,当然,安装好了nodejs之后,node还有一个npm(node package manage),这个工具,在新版本的node中已经集成了进来,所以我们可以直接使用了,通过npm我们不仅可以下载node的各种包,我们还可以下载各种在npm生态网上的包,例如jQuery,angularJS,bootstrap,等等很多包,还包括gulp,bower,grunt等等工具,这个我们下节再去讨论,本文 如有错误,还请指正,谢谢!","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://github.com/blackgan3/tags/node-js/"}]},{"title":"vuex简介","slug":"vuex简介","date":"2017-07-30T12:58:00.000Z","updated":"2018-03-23T08:25:19.500Z","comments":true,"path":"2017/07/30/vuex简介/","link":"","permalink":"http://github.com/blackgan3/2017/07/30/vuex简介/","excerpt":"vuex是vue中单向数据流的一个状态管理模式，它可以集中存储管理应用中所有组件的状态，并且有一套相应的规则可以去预测数据的变化。类似与此的还有react中的redux,dva等状态管理模式。","text":"vuex是vue中单向数据流的一个状态管理模式，它可以集中存储管理应用中所有组件的状态，并且有一套相应的规则可以去预测数据的变化。类似与此的还有react中的redux,dva等状态管理模式。 一般我们的状态管理包含以下几个部分： state 这是驱动页面变化的数据源 view state数据展示的视图 action 在view层用户操作数据变化的响应 vue中的数据流为单向数流 单向数据流在兄弟组件需要传参或者多个组件需要使用同一个状态并且多个组将都可以改变该状态时不易进行维护。 因此，我们采取的是将多个共用的状态抽离到一个全局单例中（实际上就是将组件的状态抽离出来进行单独管理），其实在redux和dva中，是将每个组件的状态抽离到它自己的单例状态中，并且这些单例状态之间是互通的。 vuex中数据流的一个大概的流程是，我们再视图层通过触发一个一个的action到mutations中，mutataions中改变对应的state,然后该state的变化会去影响所对应的视图层的html结构。 当然正如其他状态机模式一样，如果你不打算开发大型单页应用，也是没必要去使用vuex。 核心概念vuex应用的核心就是store,store中包含着我们应用中的大部分状态，vuex的状态存储是快速响应的，当store中的state有变化时，相应的组件也会快速的更新。并且我们需要遵循vuex中的规则，无法直接去改变state,改变store中的状态的唯一途径就是通过commit. 通过每次的commit中所含的信息，我们可以轻松明确的去看到我们每次改变state的意图，这样也方便我们将来对数据的追踪。 state由于vuex使用单一状态树，也就是一个应用中的state你可以全部放到这一个store中，但是如果你放置的状态过多的时候，这也是挺鸡肋的不是？我还没有去看vuex如何将状态和状态变更的事件分布到各个子模块中去。 mapState是vuex提供的简化数据访问的辅助函数，mapState函数返回的是一个对象，通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给computed属性。 当然，使用vuex并不意味着我们将所有的状态放入vuex，虽然将所有的状态放到vuex会使状态变化更显示和易调试，但是如果全部放到了全局Store中我们的代码会变得冗长和不直观，所以这些个东西还需要边开发边权衡吧。 Getter有时候我们需要从store中的state中派生出一些状态，例如对列表进行过滤并计数：12345computed: &#123; doneTodosCount () &#123; return this.$store.state.todos.filter(todo =&gt; todo.done).length &#125;&#125; vuex允许我们在store中定义“getter”.就像计算属性一样，getter返回值会根据他的依赖被缓存起来，且只有当他的依赖值发生了改变才会被重新计算。 getter接受state作为其第一个参数：12345678910111213const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) getter会暴露store.getters对象：getter类似于dva中的reducer。1store.getters.doneTodos // -&gt; [&#123; id: 1, text: '...', done: true &#125; getter也可以接受其他getter作为第二个参数：1234567getters: &#123; // ... doneTodosCount: (state, getters) =&gt; &#123; return getters.doneTodos.length &#125;&#125;store.getters.doneTodosCount // -&gt; 1 我们可以很容易的在任何组件中调用它：12345computed: &#123; doneTodosCount () &#123; return this.$store.getters.doneTodosCount &#125;&#125; mapGetters辅助函数mapGetters辅助函数仅仅是将store中的getter映射到局部计算属性。例如：123computed:&#123; ...mapGetters(['getter1','getter2'])&#125; 按照上述写法，全局store中的getter1和getter2函数便可以在局部组件中使用了。如果想将一个getter属性另取一个名字，使用对象形式：12345computed:&#123; ...mapGetters(&#123; newGetter:\"oldStoreGetter\" &#125;)&#125; Mutation更改Vuex的store中的状态的唯一办法是提交mutation.Vuex中的mutation非常类似于事件，这有点类似于dva中的effects,每一个mutation都会有一个字符串的事件类型和一个回调函数。这个回调函数就是我们实际进行状态更改的地方。并且他会接受state作为第一个参数：12345678mutations: &#123; setAdminInfo(state,adminInfo)&#123; state.adminInfo = adminInfo; &#125;, setCityList(state,cityList)&#123; state.cityList = cityList &#125; &#125; 当然了，我们还不能直接调用mutation handler,我们想要执行此函数时，需要以相应的type调用store.commit方法: 当我们需要给mutation传参时，我们需要通过payload来进行,上述例子中的adminInfo就是我们要传的的参数，在vuex中叫payload，当然，官方的建议是payload尽量是一个对象，这样我们在使用的时候能够更好的去追踪数据流。 当然，更好的调用mutation的方式是commit包含type属性的对象：1234567store.commit(&#123; type:'updateAdminInfo', adminInfo:&#123; username:'allen', password:'qwe123', &#125;&#125;) mutation需要遵守vue的响应规则 既然Vuex的store中的状态是响应式的，那么当我们变更状态时，监视状态的vue组件也会自动更新。这就意味着Vuex中的mutation也需要与Vue一样遵守一些注意事项： 在store中初始化好所有的属性 使用新对象替换老对象，即每次都返回一个全新的state对象，可以使用Object.Assign的方式。 使用常亮替代Mutation事件类型 使用常量替代mutation事件类型再各种flux实现中是很常见的模式。可以使我们整个项目的数据流向一目了然。 当然，另外重要的一点就是mutation必须是同步函数，当我们再debug一个app并且观察devtool的mutation日志时，每一条mutation被记录，都需要捕捉到前一状态和后一状态的快照。 我们可以在组件中使用this.$store.commit(“example”)提交mutation,或者使用mapMutations辅助函数将组件中的methods映射为store.commit调用。12345678910111213141516import &#123; mapMutations &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapMutations([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` // `mapMutations` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)` ]), ...mapMutations(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` &#125;) &#125;&#125; ActionAction类似于mutation,不同在于: Action提交的是mutation，而不是直接变更状态。 Action可以包含任意异步操作。 下边来看一个简单的action的例子：store 1234567891011121314151617181920212223242526272829 state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit(&apos;increment&apos;) &#125; &#125;&#125;)const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit(&apos;increment&apos;) &#125; &#125;&#125;) Action通过store.dispatch方法触发：1store.dispatch('increment'); 使用action进行触发mutation可以不用受必须同步执行的约束。我们可以在Action内部执行异步操作。 同样Action中也可以使用payload来传递参数1234store.dispatch(&#123; type:\"increment\", amount:10&#125;) 同时，Action通常是异步的，store.dispatch可以处理被触发的action的处理函数返回的Promise,并且store.dispatch仍然返回Promise. 现在，我们已经不需要去执行promise.then函数了，我们直接用async/await就可以了。123async action1(&#123;commit&#125;)&#123; commit('gotData', await getData());&#125; Module使用单一状态树，应用的所有状态会集中到一个比较大的对象中。当应用变得非常复杂时，store对象就会变得十分臃肿。 vuex允许我们将store分割成模块，每个模块拥有自己的state,mutation,acion,getter,甚至是嵌套子模块，从上至下进行分割。12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 模块的局部状态对于模块内部的mutation和getter,接受的第一个参数是模块的局部状态对象。同样的，对于模块内部的action，局部状态通过context.state暴露出来，根节点状态则为context.rootState； 对于模块内部的getter,根节点状态会作为第三个参数暴露出来； 命名空间默认情况下，模块内部的action,mutation,和getter是注册再全局命名空间的–这样可以使多个模块能够对同一个mutation或action作出响应。 当然，模块化中，我们可以使用namespaced:true的方式使其成为命名空间模块。当模块被注册之后，他的所有getter、Action、以及mutation都会自动根据模块注册的路径调整命名。启用了命名空间之后，便是将一个整体的store给分割成了一个个模块。 模块动态注册在store创建之后，你可以使用store.registerModule方法注册模块：12345678// 注册模块 `myModule`store.registerModule('myModule', &#123; // ...&#125;)// 注册嵌套模块 `nested/myModule`store.registerModule(['nested', 'myModule'], &#123; // ...&#125;) 当然，我们也可以通过store.unregisterModule（moduleName）来动态卸载模块。但是我们无法使用此方法去卸载静态模块。 Vuex并不限制你的代码结构。但是，他规定了一些需要遵守的规则： 应用层级的状态应该集中到单个store对象中。 提交mutation是更改状态的唯一办法，并且这个过程是同步的。 异步逻辑都应该封装在Action里面。","categories":[],"tags":[{"name":"vuex","slug":"vuex","permalink":"http://github.com/blackgan3/tags/vuex/"},{"name":"vue.js","slug":"vue-js","permalink":"http://github.com/blackgan3/tags/vue-js/"}]},{"title":"nodejs基本语法","slug":"nodejs基本语法","date":"2016-09-02T06:36:41.000Z","updated":"2018-03-23T08:25:19.510Z","comments":true,"path":"2016/09/02/nodejs基本语法/","link":"","permalink":"http://github.com/blackgan3/2016/09/02/nodejs基本语法/","excerpt":"nodejs是JavaScript的一个在后端的运行环境,关于nodejs的认识,我们可以看上一篇文章&lt;&lt;初识nodejs&gt;&gt;,我们要使用nodejs,首先要安装nodejs,安装的东西你可理解为java中的运行环境一样,至于怎么安装,我们最好安装nvm(nodejs version manage),安装的过程也写在了另一篇博客&lt;&lt;nodejs安装&gt;&gt;(那时懵懂期,回头再修改的详细一点)","text":"nodejs是JavaScript的一个在后端的运行环境,关于nodejs的认识,我们可以看上一篇文章&lt;&lt;初识nodejs&gt;&gt;,我们要使用nodejs,首先要安装nodejs,安装的东西你可理解为java中的运行环境一样,至于怎么安装,我们最好安装nvm(nodejs version manage),安装的过程也写在了另一篇博客&lt;&lt;nodejs安装&gt;&gt;(那时懵懂期,回头再修改的详细一点) 那么nodejs作为一个后台的平台,他可以为我们提供的很多,我们可以用JavaScript语言进行文件的获取,删除等等文件操作,我们可以用JavaScript开一个本地服务器,我们可以和mongoDB配合来搭建后台,他给我们前端带来了太多的惊喜,让我们深深的迷恋上了它,但正所谓学一个新知识时,我们都需要从简,从基础学起,那么在nodejs环境下,我们的基本语法又是怎样的呢? 模块 nodejs是支持ES6的,所以在这里你可以尽情的去写,不用考虑浏览器不兼容了(这里是后端,哈哈),安装好了nodejs后,我们在终端输入node,就会进入到nodejs环境,这里我们可以输入:1console.log(&quot;hello world!&quot;); 可以看到我们控制台输出了hello world,我第一次写的时候还以为这是chrome的开发者模式呢,这或许就是chrom v8引擎的作用吧,我们这些简单的指令可以直接在终端中输出,那么如果是运行一大段代码呢?我们可以写个js文件里边,12345在hello.js中var hello = function()&#123; console.log(&quot;hello function&quot;); &#125;hello(); 然后node hello.js,这样我们文件中写的程序就能运行出来了,nodejsshi是基于commonJS的,所以当我们的程序变大的时候,就可以使用模块了,nodejs是模块化的,什么是模块,每个模块就是nodejs的每个功能,我们有http模块来提供服务器,有fs模块来提供对文件操作的各种功能,我们写的代码可以分成一个一个的模块,这样可以提高我们代码的复用性,以及减少代码之间的耦合性,可以避免函数名和变量名的冲突. java和python使用import来导入其他函数库,而php和ruby是通过require,上边也说过,nodejs是基于CommonJS的,在node中我们可以使用require这个关键字来导入模块.例如:12var http = require(&apos;http&apos;);var fs = require(&apos;fs&apos;); 首先,我们可以使用原生的和外部的模块,这些模块都是别人写好的或者nodejs自带的,他们都给我们提供各种各样的功能,我们只需要直接require它们就能使用了,其次,我们也可以自己编写模块,比如你讲一个输出hello的函数单独封装成一个模块,1234567//这里是hello模块(function()&#123; var hello = function()&#123; console.log(&quot;hello&quot;); &#125; export.hello = hello;&#125;)() 这里我们使用exports导出hello函数,然后再另一文件中通过require导入另一个模块,这时再另一个模块中,12var hello = require(&apos;hello.js&apos;);//然后运行hellohello.hello();//这时输出hello 我们还有另一种导出方法,在hello.js中1234module.exports=hello;//通过这种导出方法,我们在使用它的时候的用法为:---var hello = require(&apos;hello.js&apos;);hello();//这时输出hello 这时我们就出现了不同的地方 exports和module.exports的区别 在讲他们的区别之前,我们先来看一个例子,这个例子以及他们区别的理解我是在[node中文社区][1]学习的.123456789var a =&#123;name:&quot;小明&quot;&#125;;var b =a;console.log(a.name);console.log(b.name);//输出 小明 小明b.name=&quot;小李&quot;;console.log(a.name);console.log(b.name);//输出 小李 小李 这里,由于a直接赋给b,这是b相当于a的引用,a和b指向同一块存储区域,这是改变了b的name,相应的a的name也发生了改变.那么这就引出了我们要讲的: module.exports原本就是一个空对象 exprots是这个对象的一个引用 平时我们require进来的就是module.exports对象 上边这三大法则就是module.exports和exports的主要区别,我们可以这样来看:123456exports = module.exports;所以现在exports.hello = hello;就相当于module.exports.hello = hello;当另一文件导入var hello = require(&apos;hello.js&apos;);时因为是导入了module.exports这个对象,所以使用hello的时候,是: hello.hello(); 所以我们导出模块的时候,直接使用module.exports=hello;就行了. 据说nodejs可以使用c/c++编写二进制模块,但因为前端出身的我虽然学过c/c++但研究不深,我还是好好的用JavaScript吧! 当我们需要使用一些线上的模块时,只需要去nodejs.org里边去搜索,然后使用npm install就可以了,npm是和nodejs捆绑在一起的, 回调函数 回调函数是什么呢?我们对于JavaScript中的函数应该不陌生了吧,回到函数就是JavaScript中的函数.当在nodejs中,回调函数是来实现异步调用的,回调函数被称为要去完成的任务,nodejs中很频繁的使用回调函数,nodejs中的所有的API模块都是由回调函数所实现的.由回调函数来实现异步调用,其实就是给你造成一种假象,让你像使用ajax一样让你感觉很顺畅,不堵不堵不堵(嘿嘿嘿)!我们先提前看一下nodejs在读取文件的时候的一个操作12345//这里有一个input.txt文件,里边的内容为:&quot;这是一个测试文件&quot;var fs = require(&apos;fs&apos;);var data = fs.readFileSync(&apos;input.txt&apos;);//同步操作console.log(data.toString());console.log(&quot;程序结束&quot;); 运行这个文件后显示123这是一个测试文件程序结束//这是我们很容易理解的程序流程,程序从上往下一次执行, 那我们再来看一个1234567//input.txt文件中的内容不变,var fs = require(&apos;fs&apos;);fs.readFile(&apos;input.txt&apos;,function(err,data)&#123; if(err)&#123;return console.eror(err)&#125; console.log(data.toString());&#125;);console.log(&quot;程序结束&quot;); 这时我们再运行这个程序,就会发现输出的内容为:123程序结束这是一个测试文件//这是我们会发现先输出的是&quot;程序结束&quot; 我们先不用去纠结上边那个函数是什么意思,我们应该能看得出来,第二次的函数是一个回调函数,这就是我们的阻塞和非阻塞IO的区别,当程序执行到异步的读文件时,会先将这个相对耗时多的步骤存入一个事件循环(looping)中,转而去执行下边的程序,等到下边的程序执行完了之后再回去执行回调函数这个它存起来的任务,而在程序执行的时候就给我造成一个感觉,好快!这就是我们异步调用,至少目前我感觉,这个异步调用时nodejs的利器. 总结nodejs的基本语句还是JavaScript,只不过它是模块化开发,更有利我们去管理代码,他的异步调用时他的一大利器,这不同于其他多线程的语言,我们只是通过回调函数来实现这一功能,所以它对服务器的压力也不大! [1]: https://cnodejs.org/topic/5231a630101e574521e45ef8","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://github.com/blackgan3/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"http://github.com/blackgan3/tags/nodejs/"}]},{"title":"初识nodejs","slug":"初识nodejs","date":"2016-08-27T06:46:26.000Z","updated":"2018-03-23T08:25:47.808Z","comments":true,"path":"2016/08/27/初识nodejs/","link":"","permalink":"http://github.com/blackgan3/2016/08/27/初识nodejs/","excerpt":"初识node.jsnode.js是什么东西? 现在流行一种说法叫web全栈工程师,讲的是一个web工程师要懂前后端,以及前端的各种牛逼技术,我觉得这个全栈工程师并不是说让你一个人去干一个团队的活,而是说你要有足够的技术思维以及技术掌控力,说白了就是你要懂的多,对于整天搞前端,和JavaScript打交道的我们来说,我们不妨来来看一个用JavaScript实现的后端平台,node.js.","text":"初识node.jsnode.js是什么东西? 现在流行一种说法叫web全栈工程师,讲的是一个web工程师要懂前后端,以及前端的各种牛逼技术,我觉得这个全栈工程师并不是说让你一个人去干一个团队的活,而是说你要有足够的技术思维以及技术掌控力,说白了就是你要懂的多,对于整天搞前端,和JavaScript打交道的我们来说,我们不妨来来看一个用JavaScript实现的后端平台,node.js. nodejs是以chrome v8为运行环境的一个平台,它不是一门语言,而是一个平台, nodejs致力于是构建速度快,稳定的网络程序更简单 它具有事件驱动和非阻塞I/O的特色,使之轻量级并且高效率 它非常适合在分布式设备运行数据密集型实时应用程序 使用chrome v8引擎? nodejs为什么要使用chrome引擎呢,据说是当时的创始人在开发nodejs的时候,想要创造出来一个高性能,异步IO,事件驱动的语言,因为JavaScript中是单线程执行的,所以没有同步IO,他便选定了JavaScript来作为基础实现的语言,同时由于谷歌的v8引擎是开源的,而且是运行JavaScript很快的引擎,便很机智的选择了chrome v8引擎来作为基础环境了, nodejs的作用? 讲到这里,我们大概的明白了nodejs是一个平台,是一个环境,它是由chrome v8引擎来做底层支持,使用JavaScript来做语言支持,大概意思就是我们之前使用JavaScript运行在浏览器端去处理dom,bom操作等等,现在JavaScript运行在服务器去处理数据的增删改查,接受请求,发送数据,查找修改文件,WHAT?这么吊?对的,现在使用JavaScript你就可以去做那些以前你觉得很牛逼的事情. 当我们输入一个url去访问网站,服务器端接受到了这个请求之后,开始去查找请求的文件,然后去执行数据库查询,查询后将响应体返回给浏览器,这是一个大致的过程,那么在以前的服务器中,例如Apache,每一个请求事件它都会去创建一个新的进程去处理这个请求, 之后,我们有了ajax,不再去进行整个页面的刷新了,而是进行局部的刷新,我们只需要去向服务器请求我们需要的那一部分数据就行了,这是一个巨大的进步. 那我们可以再去设想一个场景,当我们在看朋友圈时,我么每一个用户的朋友圈都在实时的更新当中,按照我们以前的做法是给每一个用户都和数据库端有一个长链接(long polling), 所谓的长链接,就是我们每个用户都和服务器有一个链接,由于服务器不会主动向浏览器发送数据,当链接建立之后,不会立马断开,服务器端会一直在等待,当浏览器需要它将更新的数据返回时它才会发送数据,例如你有一个朋友在微信上给你发了一条消息,这是服务器端就会向你的微信端发送一个消息,当浏览器端接受到了消息之后,会将当前链接断开,但是会再理解建立一个链接. 我们以前的这种做法的弊端就是服务器开销太大,一直都有链接占用着资源,那么怎么解决呢?用nodejs就可以解决,nodejs有着非阻塞IO和事件驱动的特点,这些术语其实并不是那么的复杂,我们可以将非阻塞IO想象成一个事件循环,这个事件循环在不停的转啊转,有请求进来时,就将他装进这个事件循环,每一个事件都有一个回调,当我们产生一个请求时,不用等待,而是直接将该进程放进事件循环中,当数据库有信息返回时再触发回调函数.每个请求就像ajax执行时那样,不需要等待,当我们的服务器请求结果返回了,事件循环就把结果传回用户的浏览器,接着继续跑,在这种方式下,我们的服务器就不会闲着了,(在多线程下有可能一些线程都没有什么用)并且从理论上讲,同一时刻的数据库查询数量,以及用户的请求数量就没有限制了,服务器只在用户那边有请求的时候才响应,这就是事件驱动.更多的可以理解为单核手机模拟四核手机的情况. 总结nodejs不是一门新的语言,他就是JavaScript的一个运行环境,JavaScript以前是在浏览器端跑,现在有了nodejs就可以在后端跑,就像汽车原本只能在公路上跑,现在你给他装了nodejs,它现在可以在水里跑了一样.那么这么抽象的说,我自己搞的也晕头转向的,对于刚趟入nodejs浑水的我.欢迎大家来一起交流!","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://github.com/blackgan3/tags/nodejs/"}]},{"title":"npm+gulp相关操作","slug":"npm-gulp相关操作","date":"2016-07-30T13:02:32.000Z","updated":"2018-03-23T08:25:19.470Z","comments":true,"path":"2016/07/30/npm-gulp相关操作/","link":"","permalink":"http://github.com/blackgan3/2016/07/30/npm-gulp相关操作/","excerpt":"在工作流相关的第一篇博客中,我们安装了nodejs的环境,那么nodejs自带的npm是一个功能十分强大的管理器,它已经不仅仅是局限于nodejs的版本管理器了,","text":"在工作流相关的第一篇博客中,我们安装了nodejs的环境,那么nodejs自带的npm是一个功能十分强大的管理器,它已经不仅仅是局限于nodejs的版本管理器了,那么当现在我们可以通过npm来下载我们需要使用的各种包,我们需要知道的是,nodejs是一个模块化的用法,它的各个功能都封装成一个一个的模块部分,关于模块的详细部分在nodejs部分再去详细介绍.那么既然它是由模块组成的,那么我们有时候就需要给我们本地的项目区添加各个模块,添加完成之后,我们自己在本地用着很爽,那当项目发布的时候,或者我们给被人传我们的代码的时候,我们还需要将项目依赖的各个模块一块打包传递过去,这是很繁琐费流量的一件事,所以我们可以在本地创建一个文件,文件中记录我们项目的信息,包括这个项目依赖的各个模块,那么别人拿到我们的的代码的时候,就可以根据我们这个文件去下载模块了,这时我们就需要用到一个文件package.json 具体的生成方式也很简单,在你想要使用npm的文件夹下打开终端,输入命令npm init,这时就会让你初始化这个package.json文件了, 生成这个文件后我们就可以使用npm指令进行模块的下载了,这里我们可以看到package.json中,有文件名,版本号,项目描述,项目主文件,全局依赖,项目依赖模块,脚本scripts等组成部分,其中,我们现在需要明白的一个地方是其中的dependencies和devDevpendenies区别,前者是你生产环境需要依赖的库,后者是你开发时候用的库,比如测试库,测试服务器之类的,在真实生产环境是不需要的,如果我们使用了构架工具,例如gulp之类的,打包的时候,是不会将dev库打包进去的.那么我们有了npm,就要来看一下它的基本使用命令吧,1234567891011121314151617181920212223242526272829301,npm install &lt;moduleNames&gt;:安装Node模块,例如: npm install gulp, npm install -g gulp//第二种为全局安装,第一种为本地安装,区别在于全局安装会将模块安装到Node的安装目录下,而本地安装时安装到当前文件夹目录下2,npm uninstall &lt;moduleName&gt;:对应的卸载模块3,npm view &lt;moduleName&gt;:查看模块的package.json文件4,npm list :查看当前目录下已安装的node包,5,npm help:查看帮助命令6,npm view moduleName dependencies:查看包的依赖关系7,npm view moduleName repository.url: 查看包的源文件地址8,npm help folders:查看npm使用的所有文件夹9,npm rebuild moduleName: 用于更改包内容后进行重建10,npm outdated:检查包是否已将过时,11,npm update &lt;moduleName&gt; 用于更新node模块12,npm search packageName :在发布一个npm包的时候,可以检查包名是否已经存在,13,npm -v :查看当前npm的版本号14,npm root :查看当前包的安装路径 那么接下来当我们的项目需要用到模块或者包的时候,我们就可以npm install它,这比你去手动的去官网下载方便了好多,当你创建好一个项目的时候,我们需要对要发布的这样项目进行好测试,打包,压缩混淆等等一系列步骤,而这些步骤正是繁琐无意义的,所以伟大的程序员就会去找工具来代替他,这就像人类发明其他工具是一个道理的,当我们厌倦了用手吃食物的时候,我们就发明了筷子和刀叉(印度除外). 目前比较流行的工具有grunt,gulp,yeoman等工具,其中gulp的核心设计时基于unix流的概念,利用nodejs的强大的流,不需要写中间文件,可以更快的完成构建,让简单的事情继续简单,复杂的任务变得可管理,而且它简单易学,它的核心API只有5个,掌握了5个API就学会了gulp,之后可以通过管道流去组件自己的任务.我们就以gulp为示例来进行一个项目的压缩管理. 首先,我们需要通过npm下载gulp,在当前项目的文件夹下打开终端输入命令npm install –save-dev gulp,下载完成后,我们可以在package.json中查看到dev依赖,在node_modules中也可以查看到.这时我们已经安装好了gulp,我们还需要再当前项目的根目录下新建一个gulpfile.js文件来进行gulp的各种任务的书写,至于为什么这么写,官方规定! 首先来个示例使用一下gulp,在gulpfile.js文件中写入以下内容: 123456var gulp1 = require(&apos;gulp&apos;);gulp1.task(&apos;default&apos;,function()&#123; console.log(&quot;默认任务执行&quot;)&#125;);//在终端中输入 gulp ,这时边执行了gulp的默认任务default,输出文字 这时我们可以看到,我们使用的require导入了gulp模块,这时commonJS格式的,在nodejs的时候会进行详解,我们现在要知道require后,gulp1就是gulp模块了.这时我们已经使用了gulp的一个API了,对,就是task,它的作用是定义一个任务.123gulp.task(任务名字,任务列表,任务动作()&#123; //这里是任务将要执行的动作&#125;) //其中任务名字,和任务动作是必须的,而任务列表是非必须的,这是一个包含任务的数组,在当前任务完成后依次执行数组中的任务. 当我们有任务的时候,我们需要去给这个任务确定执行目标,这时候就引出了我们的另一个API,gulp.src();12345678gulp.src(&apos;src/js/*.js&apos;) .pipe(零件1)//零件就是值要对当前文件执行的操作,例如压缩, .pipe(零件2) .pipe(零件3);//我们之前就说过,gulp是基于nodejs强大的流的,我们通过src找到文件夹js下的所有js类型的文件,//然后这些js文件就像进入了一个流水线一样,//通过第一个管道来到第一个函数装配第一个零件,然后再通过管道流向了其他配件处,直到整个工程完毕. 我们现在可以创建一个任务,然后匹配到所有的js文件,对他们进行一系列操作,那么操作完成的文件呢?比如我们将所有的js文件进行了压缩,混淆,那这一部分文件放在哪去呢?当然不能够将原文件变成压缩后的文件了,这时候,我们需要将这些文件流向指定的文件夹.gulp中为我们提供了一个API,gulp.dest():123456789gulp.task(&apos;jsminTask&apos;,function()&#123; gulp.src(&apos;src/js/*.js&apos;). pipe(gulp.dest(&apos;dist/js/&apos;));&#125;);//在这个任务中,当动作执行到即将完毕的时候,//会将当前管道中的文件流向dest()中的文件夹下,//如果dest()中的文件夹不存在会自动创建 现在我们基本上已经可以来创建一个成形的任务了,但是,因为gulp中的api很少,而它的大部分API都是需要下载,当然我们可以使用npm下载,这里我们示例中就对于这个文件进行压缩,混淆,打包这三个步骤,它所依赖的包分别是jsmin,uglify,concat.我们可以去npm的官网,npmjs.com中去查找我们需要的包,而且我们也不需要去死记硬背各个包的作用,因为它的包实在是太多了,多到你记不完,我么只需要记住几个常用的包,当使用的时候可以进行查找,每个包的介绍都有用法实例,1234567gulp.task(&apos;jsminTask&apos;,function()&#123; gulp.src(&apos;src/js/*.js&apos;). pipe(concat(&apos;all.js&apos;)). //打包成一个文件 pipe(jsmin()).//进行压缩 pipe(uglify()).//进行混淆 pipe(gulp.dest(&apos;dist/js/&apos;));//流向指定的文件夹下&#125;); //在终端输入gulp jaminTask就会执行当前任务了,执行完任务可以去dist/js下查看是否有all.js文件夹//我们对css的打包压缩等操作可以去在设置一个cssminTask任务,HTML压缩同理 我们已经算是成功的对一个项目进行了发布前的工具发操作,但是我们还发现一个问题,那就是,当我们改动了项目中的文件内容后,我们还需要手动去再执行一次任务,这显然是很不智能的,所以便有了gulp.watch这个api,12gulp.watch(&apos;src/js/*.js&apos;,[&apos;jsminTask&apos;]);//这个API的作用是监听js文件,当js文件发生改变的时候,就执行jsminTask任务. 好了,讲到这里,我们的文件操作已经完成了,今天的分享就到这里,本文若有错误或不足,还请指正补充,谢谢!","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://github.com/blackgan3/tags/npm/"},{"name":"gulp","slug":"gulp","permalink":"http://github.com/blackgan3/tags/gulp/"}]},{"title":"php+mysql基础操作","slug":"php-mysql基础操作","date":"2016-06-30T12:58:00.000Z","updated":"2018-03-23T08:25:19.515Z","comments":true,"path":"2016/06/30/php-mysql基础操作/","link":"","permalink":"http://github.com/blackgan3/2016/06/30/php-mysql基础操作/","excerpt":"PHP可以说是当下很火的一门后端语言了,它小巧玲珑,和html等前端语言配合的可以说是天衣无缝,加之xampp,wampp等工具的出现,更是前端开发者的福音,作为一名前端ER,如果不熟悉一门后端语言的话,那简直都不好意思说自己要加薪,那么我们对于php这门语言学习时,如果我们对js或者其他任何一门语言学的好的话,再去学习一门新的语言那是很好上手的,","text":"PHP可以说是当下很火的一门后端语言了,它小巧玲珑,和html等前端语言配合的可以说是天衣无缝,加之xampp,wampp等工具的出现,更是前端开发者的福音,作为一名前端ER,如果不熟悉一门后端语言的话,那简直都不好意思说自己要加薪,那么我们对于php这门语言学习时,如果我们对js或者其他任何一门语言学的好的话,再去学习一门新的语言那是很好上手的,无非就是先从变量,常量,执行语句,循环条件判断,数组,函数,面向对象,加上这门语言的一些高级函数,什么date,画图,浏览器信息存储函数啦,逐个的去看去对比,真的很顺手有没有,那么我们今天就来看一下我们前端经常用到的一些php+mysql操作,这需要我们有一定的mysql基础了. 当我们建好了一个表的时候,我们很自然的就会去想到,我们要怎么去查找信息,增加信息,修改信息,删除信息,那么这就是我们最基础的操纵了,在操作这个数据表之前,我们需要先找到它 代码1:1234567891011121314151617181920 1 //这里我们使用mysql_connect来进行数据库的链接,它一共有三个参数,分别是,数据库地址,用户名,用户密码,对于mysql的配置,我们可以使用shell命令行或者myphpAdmin进行界面配置 2 $con = mysql_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;123&apos;); 3 if($con)&#123; 4 echo &quot;连接数据库成功&quot;; 5 &#125; 6 else&#123; 7 echo mysql_error(); 8 echo &quot;连接数据库失败&quot;; 9 &#125;10 //当我们连接到了整个数据库后,我们需要去找到库中我们的小仓库,这里使用函数mysql_select_db(&apos;仓库名&apos;);11 if(mysql_select_db(&apos;mysql&apos;))&#123;12 echo mysql_error();13 &#125;14 15 //设置转码字符16 if(mysql_query(&apos;set names utf8&apos;))&#123;17 18 &#125;else&#123;19 echo mysql_error();20 &#125; 需要说明的是,在php5之后,对于MySQL数据库操作的函数开头变为了mysqli,这两者的区别也是有的,mysqli的功能更强大,增加了面向对象功能,但它也是向下兼容的,在用法上二者有细微的差别,这里我们的实例都是使用的mysql开头的函数,当我们成功连接到数据库后,我们先来进行插入数据 代码2: 首先我们先建立一个表单,指定提交方式为post,当提交时执行a.php文件12345678910&lt;?php //此处执行代码1进行数据库连接功能,连接到数据库后 $username = $_POST[&apos;username&apos;];//从超级全局变量中取到表单提交过来的值 $password = $_POST[&apos;password&apos;]; //这里就是我们的数据插入语句,其中uers是代码1中小仓库mysql总的一个表,表名为users; $sql = &quot;inset into users (username,password)values(&apos;$username&apos;,&apos;password&apos;)&quot;; mysql_query($sql);//使用mysql_query()函数来执行sql语句来达到操作数据库,它就像是一个终端,可以执行我们输入的mysql操作语句, ?&gt; 对于代码2,首先是建立一个提交表单,每一输入框中设定它的name属性,每一个name属性就是超级全局变量数组$_POST中的key值,所以在php中我们可以获得提交的值,在插入语句的书写时,因为我们在php中的书写方式是以字符串的形式来书写的,所以不会有编译器的提示功能,就算写错 编译器也不会立马提醒你,所以在这块一定要多注意,特别是双引号,单引号嵌套的问题,当我们插入了一条语句后,那你说姓名数错了,我想要改一些,那么php当然可以改,那么在修改的时候我们就要注意了,修改不像插入一样,直接插入到了表尾,这是计算机就会问了,我要修改哪一个呢 代码3:1234567891011121314 1 //还是原来的表单,和原来不一样的配方, 2 //在数据库中,我们给每一行记录都加一个ID,这个字段称为主键,我们将它设置为自增的. 3 //我们在点击修改按钮时将id通过get方法传送过来,这是就可以通过id获得数据条了, 4 //获得传过来的id值 5 $id = $_GET[&apos;id&apos;]; 6 //执行mysql语句,返回选择中的资源 7 $query = mysql_query(&quot;select * from article where id=$id&quot;); 8 //通过mysql_fetch_assoc函数来将数据转换为一个关联数组,还有几个作用类似的函数,我们在代码5中介绍, 9 $data = mysql_fetch_assoc($query);10 &lt;form action=&apos;b.php&apos; method=&apos;post&apos;&gt;11 &lt;input type = &apos;text&apos; name=&apos;username&apos; value=&quot;&lt;?php echo $data[&apos;username&apos;]?&gt;&quot;//将要修改的信息输出到修改框中12 &lt;input type = &apos;text&apos; name=&apos;password&apos; vlaue=&quot;&lt;?php echo $data[&apos;password&apos;?&gt;&quot;13 &lt;input type = &apos;submit&apos; value=&apos;提交修改&apos; &gt;14 &lt;/form&gt; 好了,上边的代码,只是我们修改数据的一个准备工作,我们在修改前,需要将要修改的数据输出到修改界面中,这样用户可以直观的看到他修改了数据,不能将修改数据搞的像输入信息一样,那样体验性从何而来,代码4:123456789101112131415//这里就和我们插入信息时情况差不多了,&lt;?php//首先执行代码1连接数据库$id = $_POST[&apos;id&apos;];$username=$_POST[&apos;username&apos;];$password =$_POST[&apos;password&apos;];//获取表单修改后的值//执行修改语句update$updatesql = &quot;update article set username=&apos;$username&apos;,password=&apos;$password&apos;where id=$id&quot;;if(mysql_query($updatesql))&#123; echo &quot;&lt;script&gt;alert(&apos;修改文章成功&apos;);&lt;/script&gt;&quot;;//修改成功&#125;else&#123; echo &quot;&lt;script&gt;alert(&apos;修改文章失败&apos;);&lt;/script&gt;&quot;;&#125;?&gt; 修改成功了我们的信息后,我们就来看一下php中常用的那些用来获取数据记录的函数:比如mysql_fetch_array,mqsql_fetch_assoc,mysql_fetch_row等等;代码5: 1234567 //$res是获取到的资源 $row1= mysql_fetch_row($res);//返回了查询到的数据的第一条 mysql_fetch_row每执行一次,都从资源也就是结果集中依次取一条数据,以数组形式返回出来,如果当前已经取到最后一条数据时,返回空结果 $row2 = mysql_fetch_assoc($res);作用是返回一个关联数组,数组的下标就是我们在数据表中的字段名,这种方式我们可以随意的对每个字段进行操作. $row3 = mysql_fetch_object($res);//返回一个对象. $row4 = mysql_fetch_array($res);//mysql_fetch_array的第二个参数是一个关联数组: 也就是说返回的数据中有一个索引数组有一个关联数组,可以在其中传入第二个参数指定输出哪一个数组,MYSQL_ASSOC只输出关联数组MYSQL_NUM:只输出索引数组,输出结果和mysql_fetch_row一样,但是它默认是输出两个数组. 看完了我们的插入和修改信息,相信对于删除信息也是很简单的了,道理都是一样的,获取到数据条的id,然后依据id去进行删除:代码6:123456789$id = $_GET[&apos;id&apos;];$deletesql = &quot;delete from article where id=$id&quot;;if(mysql_query($deletesql))&#123; echo &quot;&lt;script&gt;alert(&apos;删除文章成功&apos;);&lt;/script&gt;&quot;;&#125;else&#123; echo &quot;&lt;script&gt;alert(&apos;删除文章失败&apos;);&lt;/script&gt;&quot;;&#125; 那么我们在实际应用中最多的另外一种情况就是查找信息了,我们可以用在数据库中信息查重,也可以用在用户登录信息的判断,数据库中的信息统计等:1234567891011121314151617//执行代码1进行数据库的连接//接收到表单提交过来的信息,$username = $_POST[&apos;username&apos;];$password = $_POST[&apos;password&apos;];//在这里,我们使用select语句去选择数据表中和username和password都相等的数据条,如果有,就证明我们输入的信息正确,能够登陆,否则,输入的信息不正确,$sql = &quot;SELECT * FROM users WHERE username=&apos;$username&apos; and password=&apos;$password&apos;&quot;;$res = mysqli_query($conn,$sql);$row = mysqli_num_rows($res);$self= mysqli_fetch_assoc($res);if($row)&#123; echo &quot;&lt;script&gt; alert(&apos;恭喜你,登录成功!&apos;); &lt;/script&gt;&quot;; header(&apos;location:../main.php?id=&apos;.$self[&apos;id&apos;]);&#125;else&#123; echo &quot;&lt;script&gt; alert(&apos;用户名或密码输入错误,请重新登录&apos;); window.location.href=&apos;../login.html&apos;;&lt;/script&gt;&quot;;&#125; 当然,文中的代码对于所获取到的值都没有进行是否为空的判断,和格式是否正确,这都是要加上去的,代码的完善性还不高,到这里,php对于mysql的基本操作算是介绍了个大概,一起加油!","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://github.com/blackgan3/tags/php/"},{"name":"mysql","slug":"mysql","permalink":"http://github.com/blackgan3/tags/mysql/"}]},{"title":"Angularjs指令","slug":"Angularjs指令","date":"2016-06-10T12:50:30.000Z","updated":"2018-03-23T08:25:19.494Z","comments":true,"path":"2016/06/10/Angularjs指令/","link":"","permalink":"http://github.com/blackgan3/2016/06/10/Angularjs指令/","excerpt":"ng通过指令这个新属性来扩展html,angular通过内置的指令来为新应用添加功能,允许你自定义指令,ng-app初始化一个ng应用程序,ng-model将元素值绑定到应用程序.","text":"ng通过指令这个新属性来扩展html,angular通过内置的指令来为新应用添加功能,允许你自定义指令,ng-app初始化一个ng应用程序,ng-model将元素值绑定到应用程序.ng-repeat指令会重复一个HTML元素,例子:12345678910&lt;div ng-app=&quot;&quot; ng-init=&quot;names=[&apos;Jani&apos;,&apos;Hege&apos;,&apos;Kai&apos;]&quot;&gt; &lt;p&gt;使用 ng-repeat 来循环数组&lt;/p&gt; &lt;ul&gt; &lt;li ng-repeat=&quot;x in names track by $index&quot;&gt; &#123;&#123; x &#125;&#125; &lt;/li&gt; &lt;/ul&gt;//track by $index加上这个就是可以提高性能,并且还可以使用重复的数组中的值输出&lt;/div&gt; ng-class是可以接受一些表达式的,经过封装和增强:和原本的设置class的情况有了一定的区别,使用实例:1&lt;div ng-class=&apos;&#123;error:isError,warning:isWarning&#125;&apos;&gt;&#123;&#123;messsage&#125;&#125;&lt;/div&gt; 这里呢我们在控制器中可以改变isError和isWarning的值是为false还是为true,哪一个为true就去赋值为哪一个样式.ng-show还有ng-hide:ng-Animate:是用来是实现动画的额.自定义指令:我们使用能促进重用的技术是将数据绑定表达式放在一个指令中,要创建一个指令,首先要定位指令要被放入的目标模块,并调用它的directive()函数,和controller一样,指令时注册在module上,不同在于指令通过module.directiveAPI来注册,module.directive接受的是一个规范化的名字和工厂函数,这个工厂函数返回一个包含不同配置的对象,这个对象用来告诉$compile服务如何进行下一步处理,工厂函数仅在编译器第一次匹配到指令的时候调用一次,通常在工厂函数中执行初始化的工作,该函数使用$injector.invoke调用,所以它可以像controller一样进行依赖注入,优先返回一个定义好的对象,而不是返回一个函数,可以使用.directive函数来添加自定义指令.要调用自定义指令，HTML 元素上需要添加自定义指令名。使用驼峰法来命名一个指令， runoobDirective, 但在使用它时需以 - 割, runoob-directive:下边的例子中定义一个指令:这个directive()函数接受指令的名字和一个函数,123456789&lt;script&gt;var app = angular.module(&quot;myApp&quot;, []);app.directive(&quot;runoobDirective&quot;, function() &#123; return &#123;restrict:&quot;A&quot;, template : &quot;&lt;h1&gt;自定义指令!&lt;/h1&gt;&quot; &#125;; &#125;); &lt;/script&gt; 调用指令的时候,我们可以使用元素名进行调用,进行调用,还可以通过属性的方式进行调用,还可以通过类名进行调用,还可以通过注释的方式进行调用,当前,你也可以限定调用的方式为特定的,这是通过restrict属性来进行特定的调用设置,实例如上一个程序中添加的那样,它的不同的值代表着不同的调用方式,E(element)作为元素名使用,A(attribute)作为属性使用,C(class)作为类名使用,M(comments)作为注释使用,restrict的默认值为EA,可以通过属性名和元素名来调用指令,一般推荐这样使用angularJS:是基于模块的框架,因此上来要创建一个自己的模块,1var myAppModule = angular.module(&quot;myApp&quot;,[]); 然后再模块上创建指令directive:1234567myApp.directive(&quot;xio&quot;,funciton()&#123;return &#123;restrict:&apos;asdc&apos;,template:&apos;&lt;div&gt;hello my directive&lt;/div&gt;&apos;,replace:true;&#125;&#125; 函数return了一个键值对组合,其中定义了标签的使用方法,属性等等内容, restrict:定义了标签的使用方法,一共四种,AECM 如果想要注释起作用,需要将replace属性设置为true;注释中指令要留有空格template:定义了标签的模板,里边是用于替换自定义标签的字符串, replace: 是否支持替换,默认为false,即为不支持当前的被替换掉 transclude:是否支持内嵌.当前的元素节点是否支持template中的内容进行内嵌 templateUrl:’hello.html’; templateCache;用来缓存模板 scope:{}用于创建一个子scope或孤立的scope,默认为false,true时会从父作用域继承并创建一个自己的作用域,而ng-controller的作用也是从父作用域继承并创建一个新作用域, link:用于dom操作任务的函数 link函数接受三个参数: scope:它代表指令被使用的作用域,在上面的例子中它等同与控制器的作用域指的是template中的作用域 elem:它代表绑定指令的元素的jQlite包裹元素,该元素已经被jQuery包裹,所以我们没有必要将它包含在$()中来进行DOM操作,*attars:它代表绑定指令的元素上的属性: priority:优先级,在同一个元素上声明了多个指令时,根据优先级决定哪个被调用,如果pritoty相同,则按照声明顺序调用,另外,no-repeat是所有内置指令中优先级最高的, 隔离指令的作用域:上边我们定义的xio指令已经非常好了,但是它有个致命的缺陷,我们在给定的作用域中仅能使用一次,现在的实现是,我们每次重用该指令的时候都要为它新创一个控制器,我们想要做的是能够把指令的作用域与外部的作用域隔离开来,然后映射到外部的作用域,可以通过创建isolateScope来完成这个目的,这样我们使用指令的scope配置 指令的内嵌使用:因为标签内部可以嵌套其他的标签,因此想要在自定义标签中嵌套其他标签,则需要:1,使用transclude属性,并设置为true2,并使用ng-transclude属性,定义内部嵌套的位置1234567myAppModule.directive(&quot;test&quot;,function()&#123; return&#123; restrict:&apos;AECM&apos;, transclude:true, template:&quot;&lt;div&gt;haha! &lt;div ng-transclude&gt;&lt;/div&gt; wuwu!&lt;/div&gt;&quot; &#125; &#125;);","categories":[],"tags":[{"name":"Angular.js","slug":"Angular-js","permalink":"http://github.com/blackgan3/tags/Angular-js/"}]},{"title":"javascript闭包","slug":"JavaScript闭包","date":"2016-05-30T12:44:24.000Z","updated":"2018-03-23T08:25:19.464Z","comments":true,"path":"2016/05/30/JavaScript闭包/","link":"","permalink":"http://github.com/blackgan3/2016/05/30/JavaScript闭包/","excerpt":"学习javaScript已经有一段时间了,在这段时间里,已经感受到了JavaScript的种种魅力,这是一门神奇的语言,同时也是一门正在逐步完善的语言,相信在大家的逐步修改中,这门语言会逐步的完善下去,在上一篇随笔中,和大家分享了JavaScript中独有的类中的继承方式,今天呢,就跟大家分享一下我这几天一直在搞,却还是搞的不是很透彻的闭包问题,","text":"学习javaScript已经有一段时间了,在这段时间里,已经感受到了JavaScript的种种魅力,这是一门神奇的语言,同时也是一门正在逐步完善的语言,相信在大家的逐步修改中,这门语言会逐步的完善下去,在上一篇随笔中,和大家分享了JavaScript中独有的类中的继承方式,今天呢,就跟大家分享一下我这几天一直在搞,却还是搞的不是很透彻的闭包问题,对于一个初学者而言,JavaScript中的闭包无疑是一个难点,而且也是我们必须要掌握的一个重点,那么今天我就跟大家分享一下我在学习闭包的时候的感悟以及相应的理解,首先,我们在一个函数中有一个变量: 代码112345671 function people()&#123;2 var age = 12;//函数中有一个变量3 ( function ()&#123; //在函数中我们再定义一个自调用函数4 alert(age);5 &#125;)();6 7 &#125; 在函数people中,有着变量age,大家应该之前都有了解到JavaScript中特有的变量作用域的问题,函数本身就是一个作用域,函数里边可以访问外边的变量,而函数外边并不能访问函数里边的变量,这样,我们就遇到了一个问题,如果我们想要获取函数中的变量age怎么办?如代码1中所示,因为自调用函数在people中,所以它可以访问它外边的变量,所以自调用函数可以访问age,那么我们就想,将这个自调用函数return出来不就行了吗?代码2:123456781 function people()&#123;2 var age = 12;3 return function ()&#123;4 alert(age);5 &#125;6 &#125;7 var xiaoMing = new people();8 xiaoMing();//会弹出文本框12,说明在people外边调用到了内部变量age 好了,通过这种方法,我们获得了函数内部的变量,那么这就叫做闭包(closure),上边的功能就是它的第一个功能,可以在函数外部通过闭包获得函数内部的变量,从形状上看,闭包就是函数里边再定义一个函数并返回,从书上以及各个博客上看到了对闭包的解释各种各样,我对闭包的理解而言,整个函数就相当于一个房子,这个房子没有门,只有一个天窗,我们在下边无法看见房子里边放的东西,而闭包就像是一个梯子,让我们爬上去可以通过天窗看到房子里边放的东西,就是连接函数外边和里边的一座桥梁,闭包对于我们的便利性是不言而喻的,然而,事物总是有着相反的一面,闭包有他的好,当然也有它的坏,现在,我们可以先用闭包做一个累加的例子:代码3:1234567891 function func()&#123;2 var count=10;3 return function()&#123;4 return ++count;5 &#125;6 &#125;7 var ss = new func();8 alert(ss());//弹出119 alert(ss());//弹出12 通过代码3我们可以看出,每次调用func中返回的闭包时,count是在累加的,这时我们心中肯定就会有很多疑惑,不是说好的函数是一个作用域吗?执行完了函数func它体内的变量应该不存在了呀?怎么每次调用的时候它都在累加呢?这就是闭包的第二个作用了,当闭包在函数体外执行时,它的体内保存了原来算是它的父类的函数的整个执行环境以及它体内调用的变量,这时他们的关系就像我们盖房子一样,func就像地基一样,ss就是我们的房顶,这时我们站在房顶上,那么地基会消失吗?显然是不能的,这时闭包的一个优点,同时也算是它的一个缺点,就是它将一个内部变量一直放到了内存中释放不了,有可能会造成内存泄露,但这也是它的一个优点,可以将作用域链拉长,但这个功能在for循环中是一个经常出错的地方: 代码4:12345678910111213 1 function func()&#123; 2 var arr=[]; 3 for (var i=0;i&lt;5;i++)&#123; 4 arr[i]=function ()&#123;//注意此处,往数组中存放的是一个函数 5 return i; 6 &#125; 7 &#125; 8 return arr; 9 &#125;10 var arr=func();11 for(var i=0;i&lt;5;i++)&#123;12 console.log(arr[i]());//这时会返回五个513 &#125; 这时我们是否也会感到同样的疑惑,这不是应该返回0-4吗?这正是闭包在应用中的一个坑,这时,我们可以这样理解,当往arr[0]中存放第一个闭包函数时,函数并没有执行,那么这时闭包中就存放了i的一个链接,它也不知道i的值是多少,当func执行完了,这时闭包中存放在i的一个作用域链接,当执行arr数组中的函数时,由于数组中的函数没有i这个变量,所以它要向上一级去寻找,这时,它就找到了func中,而此时func中i的值已经变为5了,所以输出的每一个数都是5.那么有因就有果,有好就有坏,有错误我们就有方法去解决:12345678910111213 1 function func()&#123; 2 var arr=[]; 3 for (var i=0;i&lt;5;i++)&#123; 4 arr[i]=(function (num)&#123; 5 return i; 6 &#125;)(i);//这时使用自调用函数 7 &#125; 8 return arr; 9 &#125;10 var arr=func();11 for(var i=0;i&lt;5;i++)&#123;12 console.log(arr[i]);//这时会输出0-413 &#125; 修改的方法一:就是将闭包改为一个自调用函数这时,传入arr[i]中的不再是一个函数,而是传入的参数i,以此类推,我们还可以返回一个闭包,只不过要让闭包中存放一个确定的值,而不再是一个变量:123456789101112131415 1 function func()&#123; 2 var arr=[]; 3 for (var i=0;i&lt;5;i++)&#123; 4 arr[i]=function (num)&#123; 5 return function()&#123; 6 return num; 7 &#125; 8 &#125;(i); 9 &#125;10 return arr;11 &#125;12 var arr=func();13 for(var i=0;i&lt;5;i++)&#123;14 console.log(arr[i]());//这时会输出0-415 &#125; 使用这种方案的时候,用新创建的函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变,所以在使用闭包时,尽量不要将后续会发生变化的变量放到闭包中.同时,闭包不仅会改变函数中的变量的使用范围变广,它同时也会改变this的作用域:1234567891011 1 var name=&quot;kkkk&quot;; 2 function People()&#123; 3 this.name=&quot;lala&quot;, 4 this.getName=function()&#123; 5 return function()&#123; 6 alert(this.name) 7 &#125;; 8 &#125; 9 &#125;10 var xiaoMing=new People();11 xiaoMing.getName()();//这时会弹出kkkk 这时,当我们返回一个闭包时,它当中存放的this绑定的对象是window,而不是People,其中的原理:我的理解就是,当你返回一个函数时,它其中的this是封闭在其中的那时候还没有执行函数,所以this的指向还没有确定,当在对象外执行闭包时,this回去找它要指向的对象,这时它就会指向window,我们可以用that来捕获this:123456789101112 1 var name=&quot;kkkk&quot;; 2 function People()&#123; 3 this.name=&quot;lala&quot;, 4 this.getName=function()&#123; 5 var that=this; 6 return function()&#123; 7 alert(that.name) 8 &#125;; 9 &#125;10 &#125;11 var xiaoMing=new People();12 xiaoMing.getName()(); 这时再输出就是lala了,当然,我们不仅可以使用这种方式来捕获this,我们还可以使用之前所学的对象冒充的方法来执行函数:1234567891011 1 var name=&quot;kkkk&quot;; 2 function People()&#123; 3 this.name=&quot;lala&quot;, 4 this.getName=function()&#123; 5 return function()&#123; 6 alert(this.name) 7 &#125;; 8 &#125; 9 &#125;10 var xiaoMing=new People();11 xiaoMing.getName().apply(xiaoMing,[]); 使用这种方式同样可以达到我们想要的目的,同时,我们使用call也是可以的.到了这里,大家应该对闭包有了一个初步的了解吧,闭包这种东西,可能理解的时候好理解一些,但是当我们实际应用的时候,刚开始可能会感觉到十分的吃力,但我们应该相信,熟能生巧,而且闭包这种东西,可能我们每天都在用,可对于它内在的原理还是一知半解,这个一定要多做练习,多做实验,当你有疑问的时候,就把代码打下来去运行一下,看一下结果,再想一下为什么会是这种结果,大家,一起加油! 本博文是博主原创,如有转载请说明出处!","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://github.com/blackgan3/tags/javascript/"},{"name":"闭包","slug":"闭包","permalink":"http://github.com/blackgan3/tags/闭包/"}]},{"title":"ajax详解","slug":"ajax详解","date":"2016-05-10T11:27:10.000Z","updated":"2018-03-21T13:00:47.535Z","comments":true,"path":"2016/05/10/ajax详解/","link":"","permalink":"http://github.com/blackgan3/2016/05/10/ajax详解/","excerpt":"ajax详解 ajax(Asynchronous Javascript AndXML)即为异步的JavaScript和XML,顾名思义,这个技术是和我们当前页面刷新无关的,因为它是异步的,在没有ajax的时候,我们如果去请求数据库中的数据就要将当前页面进行刷新,最常用的你可以想到我们的表单验证部分,以前都是填完了所有的表单去一次性验证,像这样的注册界面,你填错了就要刷新页面从头再来,所以,现在有了ajax你可以填一个表格就进行一次验证,而且页面并不会刷新.","text":"ajax详解 ajax(Asynchronous Javascript AndXML)即为异步的JavaScript和XML,顾名思义,这个技术是和我们当前页面刷新无关的,因为它是异步的,在没有ajax的时候,我们如果去请求数据库中的数据就要将当前页面进行刷新,最常用的你可以想到我们的表单验证部分,以前都是填完了所有的表单去一次性验证,像这样的注册界面,你填错了就要刷新页面从头再来,所以,现在有了ajax你可以填一个表格就进行一次验证,而且页面并不会刷新. 对于ajax,他的核心技术是对象,它的整个作用过程其实是当前页面继续工作,它会自己开一个时空隧道和当前界面一起工作,就行两个平行空间一样,它的整个过程可以总结为先创建XMLHttpRequest对象,然后连接服务器,发送请求,最后接受服务器发送过来的数据,好了,XMLHttpRequest是一个可以让我们前端和后端连接起来的十分神奇的对象,我们首先来创建一个XMLHttpRequest对象 复制代码123456789 var xhr =null; if(window.XMLHttpRequest)&#123; xhr = new XMLHttpRequest(); &#125;else&#123; xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); &#125;//这里进行的是针对IE浏览器的兼容性处理,在IE中,我们的xmlhttprequest对象就变成了activeobject,而且里边的参数是不能少的,IE就是这样倔强复制代码 当我们拥有了一个xhr实例后,我们就可以进行向数据库中发送请求,这里我们先来看一下我们需要用的方法,open()方法是建立前端到服务器的请求,而send方法是向服务器发送请求,也就是说,当我们在叫外卖的时候,我们用的美团就像是open()方法,建立我们和店家的联系,而快递小哥就是我们的send()方法,他将我们的美味给我们送过来,这里我们先用get方法做一个示例,在下一块我们再区看一下我们的两种请求方法get和se的区别:123var url =&quot;index.php?id=1&quot;;xhr.open(&apos;get&apos;,url,&apos;true&apos;);//open中有三个参数,第一个参数用来指定使用get还是post方式提交,第二参数是指定要发送的url地址,第三个参数指定是否使用异步,第三个参数默认是true;xhr.send(); 这是我们已经使用get方式向index.php发送了一个请求,我们穿过去的参数为”id=1”;那么我们先来看一下和get和post区别,get和post都是用来进行发送数据的方式,从字面意思来看,get(得到)是从数据库得到东西的请求方式,而post(发送)是要给服务器传送数据的,而且post方式传送数据是经过加密的,post传送的数据放在请求体里边,而get方式只有请求头,没有请求体,所以get也可以传给数据库少量数据,发送的方式是在url地址后边用?做表示,如果有多个参数用&amp;隔开,我们先来看一下post的用法: 12345var url = &quot;index.php&quot;;var data = &quot;id=1&quot;;xhr.open(&apos;post&apos;,url,true);xhr.setRequestHeader(&apos;Contenttype&apos;,&apos;application/x-www-form-urlencoded&apos;)//post请求需要设置请求头信息xhr.send(data);//在这里将数据发送过去, 那么现在我们已经简单的向服务器端发送了请求,我们正常的一个流程是,服务器会根据我们的参数或者是它自身运算的结果来给我们返回数据,这里我们并不是一定要发送给数据库参数的,举个例子,服务器里有一个数组[“0”:”苹果”,”1”:”橘子”,”2”:”香蕉”],现在如果我们不传参,服务器会将这一个数组都return给我们,如果我们穿一个id=1,这时返回的数据就是橘子,我们要理解的就是,我们传的参数和数据对于我们获得数据只是一个辅助作用,真正起作用的还是服务器内部的结构,那么我们现在发送了请求后,我们面临一个问题,我们怎么判断请求是否发送成功以及服务器时候处理了我们的请求,还有如果服务器响应了,它返给我们的数据我们该怎么去获取呢? 好的,让我们来看一下,xhr实例上有一个readystate属性,这个属性的代表着当前xmlHttpRequest的状态: 0:请求没有发出(在调用open之前) 1:请求已经建立但还没有发出 2:请求已经发出 3:请求正在处理当中 4:请求已经被服务器处理完毕,相应准备就绪 每当readystate状态改变的时候,就会调用onreadystatechange()这个函数,所以我们可以在onreadystatechange进行相应状态的判断以及相应返回数据的获取,当readystate为4时,代表着我们的请求被服务器成功的执行,但我们还需要判断,我们的需要的数据是否成功被返回了呢?我们还有一个status属性,而这个status也有很多的状态码代表着不同的响应状态,其中200代表着响应成功,并且将响应的数据返回到了前端中: 1234567xhr.onreadystatechange = function()&#123; if(xhr.readystate == 4)&#123;//请求已经成功被处理 if(xhr.status == 200)&#123;//成功的从服务器得到了响应 //这里进行处理返回的数据 &#125; &#125;&#125; 得到了响应之后,responseText表示字符串形式的相应数据,responseXML表示获取XML形式的响应数据,getAllResponseHeader():获取所有的响应报头,这里我们来完整的写一个ajax请求: 123456789101112131415161718var xhr =null; if(window.XMLHttpRequest)&#123; xhr = new XMLHttpRequest(); &#125;else&#123; xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); &#125; var url =&quot;index.php?id=1&quot;; xhr.open(&apos;get&apos;,url,&apos;true&apos;);//open中有三个参数,第一个参数用来指定使用get还是post方式提交,第二参数是指定要发送的url地址,第三个参数指定是否使用异步,第三个参数默认是true; xhr.send(); xhr.onreadystatechange = function()&#123; if(xhr.readystate == 4)&#123;//请求已经成功被处理 if(xhr.status == 200)&#123;//成功的从服务器得到了响应 alert(responseText); &#125; &#125; &#125;相应的后端会在后边用php实现一个小的demo 二,XML和json 当我们完成了发送请求并且从后端获取了数据后,我们应该再进一步的去思考,那么我可以指定从后端传过来的数据吗?那么接下来就出现了我们的json和XML数据格式,这两种都是我们进行前端和后端进行传送数据的格式,那么我们先来看一下XML,XML数据其实你也可以看做我们的html标签,只不过它是我们可以自定义的标签,你可以给它的标签名取的很有意义,那样就会很方便你去使用: 12345678&lt;china&gt; &lt;province name=&apos;河南&apos;&gt; &lt;city&gt;郑州&lt;/city&gt; &lt;/province&gt; &lt;/china&gt;//这就是一个简单的XML格式的数据,我们对于这样的数据进行操作的时候可以使用js操作DOM对象的方法,//xml数据必须有一个根节点 另外一种经常使用的数据格式就是json了,json是一种独立于语言的数据格式,就是说它是可以在很多种语言中使用的,不限定于某一个特定的语言,而且它相较于xml来说代码量较小,而且易于解析,xml就有些数据量庞大解析不便了,但是碍于json出现的较晚,所以现在大部分人还是使用的xml,无奈与很多后端数据都是用xml存储,json的格式有些类似于我们的JavaScript中的对象字面量: 12345&#123;&quot;name&quot;:&quot;james&quot;, &quot;hobby&quot;:&quot;basketball&quot;, &quot;son&quot; : &#123;&quot;littleson&quot;:&quot;er&quot;,&quot;bigson&quot;:&quot;san&quot;&#125;&#125;//这种就是一个简单的json格式数据,json数据代码量较小,但是可读性来说还是xml看着比较顺眼,但是人看着不顺眼的代码块恰恰是机器最喜欢的 得到了数据,我们还需要去解析一下才能够使用,相较于xml有些dom一样的解析方法,xml的解析在js中最长用的解析方法就是json.parse()了,而将js对象转化为json对象我们使用json.stringify(),当然了,json和xml的区别还有很多,这里我献上一个前辈的总结,很详细的一个总结: http://www.cnblogs.com/SanMaoSpace/p/3139186.htm 三,ajax在jQuery中 那么我们之前已经看了ajax在js中的应用,jQuery号称是js的最强悍的一个封装库,怎能没有ajax的封装呢?我们先来简略的看一下jQuery源码中对于ajax的封装: 123456//它的大概位置在七千行左右jQuery.extend(&#123; ajax: function( url, options )&#123;&#125;&#125;);//从这个大概形式中,我们可以看得出来,ajax时封装在jQuery的工具方法中,是在jQuery上直接封装的,所以调用的时候直接使用jQuery这个函数就行,所以我们对于它的调用就是$.ajax(); 那么我们还是写一个简单的post请求方式在jQuery中的应用: 123456789101112131415 $.ajax(&#123; type:&quot;post&quot;, //请求方式 url:&quot;a.php&quot;, //服务器的链接地址 dataType:&quot;json&quot;, //传送和接受数据的格式 data:&#123; username:&quot;james&quot;, password:&quot;123456&quot; &#125;, success:function(data)&#123;//接受数据成功时调用的函数 console.log(data);//data为服务器返回的数据 &#125;, error:function(request)&#123;//请求数据失败时调用的函数 alert(&quot;发生错误:&quot;+request.status); &#125;&#125;); 有了post请求方式的例子,想必get方式的写法大家也不在话下,看着jQuery的例子,是不是感觉很简单呢,很多兼容性的处理jQuery都已经帮我们做好了,就是这个feel. 四,跨域请求 在上边的例子中,我们使用ajax请求的都是在本地和我们同源的文件,因为JavaScript在设计时出于安全方面的考虑,不允许跨域请求,那么什么情况才算是跨域呢? 上边的就是我们的不同源的情况,遇到这种情况,再去使用上边所讲的方式就不行了,那么我们该怎样去解决跨域请求的问题呢?JSONP(JSON with Padding)是 JSON 的一种“使用模式”，可用于解决主流浏览器的数据访问问题,因为html的元素标签可以从其他来源动态的加载数据,所以我们可以利用标签来实现跨域请求,这种方式就成为jsonp,当然了,jsonp和json可不是一回事,json是数据的一种传输格式,而jsonp是一种跨域请求方式,简单的理解就是: 123456&lt;html&gt;&lt;body&gt; &lt;script src=&apos;test.js&apos;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;//script中的src没有同源限制,它可以加载其他任意文件.而jsonp利用的就是这一个功能展开的 对于jsonp这种跨域请求方式,我们首先先来写一个例子,然后再根据这个例子去慢慢的介绍: 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;jsonp&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;http://cdn.weather.hao.360.cn/api_weather_info.php?app=hao360&amp;_jsonp=weather&amp;code=131111&quot;&gt;&lt;/script&gt;//这是360天气的一个天气预报的一个api接口,&lt;/body&gt;&lt;/html&gt; 当我们运行上边例子后,在chrome浏览器中打开开发者模式-&gt;点击network-&gt;查看请求包-&gt;点击response,这时我们可以查看到: 是的这时候远方的数据库中向我们返回了一大串数据,仔细观察的话,不难发现,这一串数据的格式就是weather( 数据 );咦,这不是一个weather函数调用吗?是的,没错,我们的数据库向我们返回的就是一个函数调用,在看一下,我们script中的url地址后边的参数_jsonp=weather,我们将它改为tianqi发现返回的是一个tianqi().哦,原来_jsonp参数是指定服务器返还给我们的函数名,那么函数中的参数就是服务器返还给我们的数据,那么我们也发现此时浏览器已经报错了: 那么也就是说我们的代码中没有weather这个函数,加上上边的讲解,我们这时应该去直接的说一下它的运行机制了,执行完script中的跨域调用后,会直接调用weather函数,所以这时候我们要再代码中写一个为weather函数让script来执行,那么weather函数中的参数就是我们要的数据,我们这时就可以在weather函数中直接使用我们的数据了,这里还要说明一点,jsonp只有get请求方式,也就是传参都要再url后边,而且其中的数据传输格式都为json, 123456&lt;script&gt; function weather(data)&#123;//回调函数 console.log(data); &#125;&lt;/script&gt;&lt;script src=&quot;http://cdn.weather.hao.360.cn/api_weather_info.php?app=hao360&amp;_jsonp=weather&amp;code=111111&quot;&gt;&lt;/script&gt; 这时我们就可以看到结果: 在这里我们使用jsonp调用数据时,我们需要先去了解一下后台数据的格式,因为我们要去传一些参数进行获取数据,所以前端后端是不分家的,那么我们当天也可以使用动态加载script标签的方法来进行点击按钮获取数据 123456function createScript()&#123; var script = document.createElement(&apos;script&apos;); var url = &quot;http://cdn.weather.hao.360.cn/api_weather_info.php?app=hao360&amp;_jsonp=weather&amp;code=&quot;; script.src = url+params; document.body.appendChild(script); &#125;//使用这个函数就可以动态的加载数据了 那么下边我们来看一下jQuery中jsonp的使用: 12345678910111213$.ajax(&#123; type:&apos;get&apos;, url:天气预报接口, async:&apos;true&apos;, // 是否为异步调用 dataType:&apos;jsonp&apos;, 指定数据传输方式 jsonp:&apos;jsoncallback&apos;, //回调函数名的key值 可省略 jsonpCallback:&apos;XBox&apos;, //回调函数的函数名 可省略 success:function(data)&#123; //成功后执行的函数,data就是我们要获取的函数值 &#125;, error :function()&#123; //失败时执行的函数 &#125; 获得数据我们可以显示在HTML标签中,有了这种异步调用方式,我们就可以去做一些很好玩的东西了,什么天气预报,快递查询,音乐播放器了,都不在话下,当然,跨域调用还有很多种,但我就对jsonp使用的多一点,其他中方法就不提啦,文章中可能会有一些知识点被漏掉,毕竟是自己的一个小总结,希望能对大家有点小帮助.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://github.com/blackgan3/tags/javascript/"},{"name":"ajax","slug":"ajax","permalink":"http://github.com/blackgan3/tags/ajax/"}]},{"title":"javascript函数参数传递","slug":"JavaScript中函数参数传递","date":"2016-05-04T13:50:13.000Z","updated":"2018-03-23T08:25:19.488Z","comments":true,"path":"2016/05/04/JavaScript中函数参数传递/","link":"","permalink":"http://github.com/blackgan3/2016/05/04/JavaScript中函数参数传递/","excerpt":"JavaScript高设读书笔记 几乎每个语言中都有函数这个概念,封装一个代码块,然后可以在任意地方进行调用,那么在JavaScript中的函数,首先在命名上我们要遵循的有以下规则: 不能把函数名命名为eval或者arguments 不能把参数命名为eval或者arguments 不能出现两个命名参数同名的情况.","text":"JavaScript高设读书笔记 几乎每个语言中都有函数这个概念,封装一个代码块,然后可以在任意地方进行调用,那么在JavaScript中的函数,首先在命名上我们要遵循的有以下规则: 不能把函数名命名为eval或者arguments 不能把参数命名为eval或者arguments 不能出现两个命名参数同名的情况. 函数声明和函数表达式的不同 解析器在向执行环境中在家数据时,对函数声明和函数表达式并非一视同仁,解析器会率先读取函数声明,并使其在执行任何代码之前可用,至于函数表达式,则必须等到解析器执行到它所在的代码行,才会真正被解释执行. 即在代码执行前,解析器会通过一个名为函数声明提升的过程,读取并将函数声明添加到执行环境中. ###有人的地方就有江湖,有函数的地方就有参数:ECMAScript函数的参数与大多数其他语言中函数的参数有所不同,ECMAScript函数不介意传递进来多少个参数,也不在乎传进来参数是什么数据类型,原因是ECMAScript中的参数在内部是由一个数组来表示的,函数接受到的永远就是一个数组,而不关心数组中包含哪些参数,这个数组中不包含任何元素的话,也无所谓,如果包含多个元素,也没有问题,这个数组就是arguments. 事实上,arguments对象只是与数组类似,它并不是Array的实例,命名的参数只是提供便利,但不是必须的, ECMAScript中的函数没有重载,不能像Java那样实现函数的重载,也是因为它的传入的参数是一个类数组有关,如果在js中定义了两个名字相同的函数,则函数会被重写,其函数会以最后一个函数体为准. 有了函数,有了参数,我们需要的就是在调用时给函数传递值了,那么传递值的时候,是值传递?还是引用传递呢?我们先看一下呢JavaScript中的变量 ECMAScript变量包含两种不同数据类型的值,基本类型值和引用类型值,基本类型值指的是简单的数据段,而引用数据类型值的那些可能由多个值构成的对象.引用数据类型的值是保存在内存中的对象,与其他语言不同的是,JavaScript不允许直接访问内存中的位置,也就是不能直接操作对象的内存空间,在操作对象是,实际上是操作对象的引用而不是实际的对象,为此,引用类型的值是按引用访问的.在很多对象中,字符串以对象的形式来表示,因此被认为是引用数据类型,ECMAScript放弃了这一传统.对于引用类型的值,我们可以为其添加属性和方法,也可以改变和删除其属性和方法,123var person = new Object();person.name = &quot;xxx&quot;;alert(person.name); //xxx ###那么JavaScript函数中的参数传递是怎么传递的呢? *首先我们需要再次明白的是:函数就是一个对象,而函数名就是这个对象的地址引用 ECMAScript中所有函数的参数都是按值传递的,也就是说,把函数外部的值赋值给函数内部的参数,就像把值从一个变量赋值到另一个变量一样,在函数中参数的传递只能是按值出传递,在向参数传递基本类型的值时,被传递的值会被复制给一个局部变量,在向参数传递引用类型的值时,会把这个值在内存中的地址复制给一个局部变量,因此这个局部变量的变化不会反应在外部,例如:12345678function addTen(num)&#123;num+= 10;return num;&#125;var count = 20;var retuslt = addTen(count);alert(count); //20alert(result); //30 这里的函数addTen()有一个参数num,而参数实际上是函数的局部变量,在调用这个函数时,变量count作为参数被传递为函数,这个变量的值为20,于是,数值20被赋值给num来给addTen使用,在函数内部,给num+10这一操作不会影响到count,这是很容易理解的,因为我们的传递就是值传递. 但如果我们传递的是对象呢?123456function setName(obj)&#123;obj.name = &quot;blackgan&quot;;&#125;var person = new Object();setName(person);alert(person.name); //blackgan 以上代码中创建一个对象,并将其保存在了变量person中呢 ,然后,这个对象被传递到了setName()函数中,之后被复制给了obj,在这个函数内部,obj和person引用的是同一个对象,换句话说,即使这个对象是按值传递的,obj也会按引用来访问同一个对象,于是,当在函数内部为obj添加name属性后,函数外部也有了反应,因为person在堆栈中指定的对象只有一个,而且是全局对象,但这很容易就让我们理解成:在函数的局部作用域中修改的对象会在全局作用域中反映出来,就说明参数是按引用传递的,那么为了证明这种说法是否正确,我们来在看一个例子12345678function setName(obj)&#123;obj.name = &quot;nic&quot;;obj = new Object();obj.name = &quot;grag&quot;;&#125;var person = new Object();setName(person);alert(person.name); //&quot;nic&quot; 这个例子与前一个例子的唯一区别,就是在setName()函数中添加了两行代码:先为obj重新定义了一个对象,另一行代码为该对象定义了一个带有不同值的name属性,在把person传递给setName()后,其name属性被设置为了”nic”;如果person是按引用传递的,那么person就自动会被修改为指向其name属性值为”grag”的新对象,但是当我们再次返回person.name时,显示的值是nic,所以可以看得出来参数的传递是按值传递的;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://github.com/blackgan3/tags/javascript/"}]},{"title":"javascript中的this指向问题","slug":"JavaScript中的this指向问题","date":"2016-03-29T14:21:25.000Z","updated":"2018-03-23T08:25:19.480Z","comments":true,"path":"2016/03/29/JavaScript中的this指向问题/","link":"","permalink":"http://github.com/blackgan3/2016/03/29/JavaScript中的this指向问题/","excerpt":"在深入学习JavaScript之后,我们越来越多的会遇到函数或者在对象内部中,对于this的指向问题的疑惑,其实基本上每一个编程语言中都有一个this,这个this的指向都是大同小异,你也可以汉化它的意思,this的意思是这个,就是本身的意思,那么在JavaScript中,我们的this代替的那个本身到底会随着代码情况的不同而有什么变化呢?今天,我们就来一体探讨一下JavaScript中关于this的指向问题:","text":"在深入学习JavaScript之后,我们越来越多的会遇到函数或者在对象内部中,对于this的指向问题的疑惑,其实基本上每一个编程语言中都有一个this,这个this的指向都是大同小异,你也可以汉化它的意思,this的意思是这个,就是本身的意思,那么在JavaScript中,我们的this代替的那个本身到底会随着代码情况的不同而有什么变化呢?今天,我们就来一体探讨一下JavaScript中关于this的指向问题:首先呢,this可以指向window对象,和其他调用它的对象,当然,在严格模式下,它指向undefined,那我们就先来看一下最简单的形式,代码1:1234561 function People (name,age)&#123;2 this.name = name;3 this.age = age;4 &#125;5 var xiaoMing=new People(&apos;xiaoming&apos;,13);6 alert(xiaoMing.name);//这时会弹出xiaoming 上边呢,是我们对于this的理解最简单的一种形式,xiaoMing是我们通过构造函数People新创建的一个对象,那么函数中的this指向的就是我们的对象xiaoMing,所有当我们调用xiaoMing.name的时候,会弹出它的名字,注意,在这里我们美创建一个对象,这个对象就会有它自己本身的this来指向它本身,好了,这是我们应用中最简单的一种方式,相信大家对于这种方式都不会有疑惑.我们接着往下看,代码2:12345678910function People (name,age,shoes)&#123;this.name = name;this.age = age;this.shoes =shoesthis.run = function ()&#123;console.log(this.name+&quot;穿着&quot;+this.shoes+&quot;在跑步&quot;); &#125;&#125;var xiaoMing=new People(&apos;xiaoming&apos;,13,&apos;nike&apos;);xiaoMing.run();//xiaoming穿着nike在跑步 那么这里呢,我们就可以看到,在类中的方法,调用到了类中的属性,是可以调用的,这个就像你要去跑步,而鞋子就是你自己的,那么你当然可以穿着你的nike鞋子去跑步了,好了,现在到了这里,我们应该都可以理解,这就是我们最基本的用法.我们接着往下看,代码3:1234567891011121314151617 1 var name = &quot;小红&quot;; 2 var shoes= &quot;adidas&quot; 3 function People (name,age,shoes)&#123; 4 this.name = name; 5 this.age = age; 6 this.shoes =shoes 7 this.run = (function ()&#123; 8 return function()&#123; 9 console.log(this.name+&quot;穿着&quot;+this.shoes+&quot;在跑步&quot;);10 &#125;11 12 &#125;)();13 &#125;14 var xiaoMing=new People(&apos;xiaoming&apos;,13,&apos;nike&apos;);15 xiaoMing.run();//1.html:241 xiaoming穿着nike在跑步16 var other = xiaoMing.run;17 other();//1.html:241 小红穿着adidas在跑步 好了从上边的代码中,我们可以明显的看到this在对象中的指向问题,要记住一点,this指向的是对象,是一个对象实体,是一个有意义的,它并不指向函数,例如代码3的第15行,run函数自调用返回的是一个闭包,有人可能会觉得第15行会返回小红,但因为第15行的调用者还是xiaoMing,所以它返回的是xiaoMing的方法,这就与第17行形成一个对比.123456789101112131415 1 function People (name,age,shoes)&#123; 2 this.name = name; 3 this.age = age; 4 this.shoes =shoes 5 this.run = (function ()&#123; 6 var timer= setInterval(function()&#123; 7 console.log(this.name+&quot;穿着&quot;+this.shoes+&quot;在跑步&quot;); 8 &#125;,30) 9 10 11 12 &#125;)();13 &#125;14 var xiaoMing=new People(&apos;xiaoming&apos;,13,&apos;nike&apos;);15 //这里会疯狂的输出小红. 这里就出来了我们要说明的第一个问题,当this在定时器当中时,this的指向为变为window,所以我们也可以这样理解,this的指向并不是定义的时候就确定的,而是在调用时确定的,这也就给我们带来了这么多的不确定性,对于this来说,我们最常用的方式,也是最容易出现指向错误的地方,应该就是匿名函数中: 12345678910111213141516 1 var name = &quot;小红&quot;; 2 var shoes= &quot;adidas&quot; 3 function People (name,age,shoes)&#123; 4 this.name = name; 5 this.age = age; 6 this.shoes =shoes 7 this.run = (function ()&#123; 8 console.log(this.name+&quot;穿着&quot;+this.shoes+&quot;在跑步&quot;); 9 10 &#125;)();11 12 13 14 &#125;15 var xiaoMing=new People(&apos;xiaoming&apos;,13,&apos;nike&apos;);16 //输出小红 对于匿名函数,我么可以这样去理解,每一个函数在执行的i时候都会去寻找它的this调用者和arguments参数,而匿名函数的this是window,所以匿名函数的执行具有全局性,所以,我们在使用匿名函数时,一定要注意它的this指向问题,我们我们可以使用that捕获,call apply和bind等方式去改正this的指向问题,1234567891011121314151617 1 var name = &quot;小红&quot;; 2 var shoes= &quot;adidas&quot; 3 function People (name,age,shoes)&#123; 4 this.name = name; 5 this.age = age; 6 this.shoes =shoes 7 this.run = (function ()&#123; 8 console.log(this.name+&quot;穿着&quot;+this.shoes+&quot;在跑步&quot;); 9 10 &#125;)();11 return &#123;&#125;;12 13 14 15 &#125;16 var xiaoMing=new People(&apos;xiaoming&apos;,13,&apos;nike&apos;);17 console.log(xiaoMing.name);//undefined 这里我们需要注意另外一个问题,就是当我们构造函数中有一个return返回值时,且这个返回值时一个对象的时候,那么this会指向这个返回的对象,而一般我们的构造函数都是没有返回值,这是我们另外要注意的一点. 好了,讲到这里,希望大家对于this的理解能够多一点点,在应用中我们多用下this,会加深我们对this的理解.有不足的地方还希望指正,谢谢!","categories":[],"tags":[{"name":"-javascript","slug":"javascript","permalink":"http://github.com/blackgan3/tags/javascript/"}]},{"title":"javascript事件委托机制","slug":"JavaScript中的事件委托机制","date":"2016-03-26T05:16:44.000Z","updated":"2018-03-23T08:25:19.475Z","comments":true,"path":"2016/03/26/JavaScript中的事件委托机制/","link":"","permalink":"http://github.com/blackgan3/2016/03/26/JavaScript中的事件委托机制/","excerpt":"前言 这几天看到一个面试题,大概就是,让你给1000个li都添加一个click事件,应该怎么添加?大多数人第一开始的感觉可能就是,每个li上边都添加一个呗,那要是这样的话,估计面试的时候就会GG了,这里就是撤出了我们的事件冒泡和捕获机制,以及事件委托机制,对于上边这些,我们慢慢来看.","text":"前言 这几天看到一个面试题,大概就是,让你给1000个li都添加一个click事件,应该怎么添加?大多数人第一开始的感觉可能就是,每个li上边都添加一个呗,那要是这样的话,估计面试的时候就会GG了,这里就是撤出了我们的事件冒泡和捕获机制,以及事件委托机制,对于上边这些,我们慢慢来看.首先说一下事件冒泡和事件捕获机制,事件冒泡是有微软公司提出来的,事件捕获是有网景公司提出来的,当时两家是争论的不可开交,后来w3c也没办法,就采取了折中的方式,事件产生后先捕获后冒泡, 通常,在js中监听事件的方法共有三种,分别是: 123 ele.addEventListener(type,listener,[useCapture]);//IE6~8不支持 ele.attachEvent(&apos;on&apos;+type,listener);//IE6~10支持,IE11不支持 ele.onClick=function()&#123;&#125;;//所有浏览器都支持 w3c规范中定义了三个事件阶段,依次是捕获阶段,目标阶段,冒泡阶段,而w3c指定的dom2级规定中,使用的是addEventListener来监听事件的.所以我们就以addEventListener来讲解,首先事假冒泡就像你从往水中扔一块石子,水中的气泡从下边往上冒一样,意思为触发事件后从子元素王父元素方向触发,而捕获机制则正好相反,捕获机制是从父元素往子元素方向进行事件触发,而addEventListener函数中的第三位参数正是来决定是使用捕获机制还是冒泡机制的,当useCapture为true是为捕获机制,当useCapture为false时是冒泡机制,我们看一下例子: 12345678910111213 &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var parent = document.getElementsByClassName(&apos;parent&apos;)[0]; var child = document.getElementsByClassName(&apos;child&apos;)[0]; parent.addEventListener(&apos;click&apos;,function()&#123; console.log(&quot;这里是父元素&quot;); &#125;,false); child.addEventListener(&apos;click&apos;,function()&#123; console.log(&quot;这里是子元素&quot;); &#125;,false);&lt;/script&gt; 当我们点击子元素是显示上图,当我们将false改为true后就会发现执行顺序会反过来,这就是事件冒泡和捕获的区别,他们两个刚好相反, 那么使用这种绑定机制我们的弊端在于要去给每一个对象绑定事件会是一个特别麻烦的事情,当我们要删除一个事件或者要改变一个事件的时候会特别的繁琐,更重要的是,我们增加了JavaScript和dom节点之间的关联,而且一点出现循环引用,很有可能造成内存泄露,这些都是它的弊端, 那么解决这种弊端的一种方法就是事件代理(event delegation),这个方法可以让你避免去给每一个节点一一的添加事件,它的做法是将这些监听事件去绑定到这些节点的父元素上,在父元素上的这个监听函数自动去判断是哪一个子元素触发的事件,从而可以对触发事件的子元素进行操作,这里我们给出的例子是davidwalsh所给出的一个例子: 现在我们有一个父元素ul和几个li子元素, 12345678&lt;ul id=&quot;parent-list&quot;&gt; &lt;li id=&quot;post-1&quot;&gt;Item 1&lt;/li&gt; &lt;li id=&quot;post-2&quot;&gt;Item 2&lt;/li&gt; &lt;li id=&quot;post-3&quot;&gt;Item 3&lt;/li&gt; &lt;li id=&quot;post-4&quot;&gt;Item 4&lt;/li&gt; &lt;li id=&quot;post-5&quot;&gt;Item 5&lt;/li&gt; &lt;li id=&quot;post-6&quot;&gt;Item 6&lt;/li&gt;&lt;/ul&gt; 现在我们要实现的是,当我们点击每一个li节点的时候,都会输出li节点中的内容,按照上边的写法,你可以选中这些li,让后给他们加上这些方法,然后等到不需要了再将他们移除,如果有100个li,1000个li呢,这将会成为你的噩梦,较好的解决方法就是给父元素添加一个监听事件,之后的问题便是怎么去判断出来时哪一个li被点击了? 我们可以在监听事件中去判断当前event的target来判断是否是我们要找的节点,这里我们有一个简单的例子: 123456789 // 找到父元素,绑定一个监听事件document.getElementById(&quot;parent-list&quot;).addEventListener(&quot;click&quot;, function(e) &#123; // e.target是点击的元素 // 如果它是li元素 if(e.target &amp;&amp; e.target.nodeName == &quot;LI&quot;) &#123; // console.log(&quot;List item &quot;, e.target.id.replace(&quot;post-&quot;, &quot;&quot;), &quot; was clicked!&quot;); &#125;&#125;); 当ul中发生点击事件后,因为addEventListener默认是冒泡事件,所以监听事件会在底层事件冒泡过来时执行,在触发了事件后,去检测是否是我们要寻找的目标元素,如果不是,就会忽略过去,那我们不仅仅可以通过目标元素的标签是不是我们需要的目标元素,我们还可以根据目标元素的属性或者类名来进行检测,利用ele.maeches这个API来进行处理, 123456 document.getElementById(&quot;myDiv&quot;).addEventListener(&quot;click&quot;,function(e) &#123; // e.target 就是当前被点击的元素 if (e.target &amp;&amp; e.target.matches(&quot;a.classA&quot;)) &#123; console.log(&quot;Anchor element clicked!&quot;); &#125;&#125;); 因此我们可以看得出来,使用事件代理这种方式,能够给我们带来很多的便捷,可以避免很多坑,使用事件代理是一种很强大的方法. 如果你无法简洁的表达你的想法，那只说明你还不够了解它。 – 阿尔伯特·爱因斯坦","categories":[],"tags":[{"name":"-javascript","slug":"javascript","permalink":"http://github.com/blackgan3/tags/javascript/"}]}]}